bool tripletSum(int x, int[] a) {
    for (int i = 0; i < a.Length; i++) {
        HashSet<int> h = new HashSet<int>();
        int c = x - a[i];
        
        for (int j = i + 1; j < a.Length; j++) {
            if (h.Contains(c - a[j])) return true;

            h.Add(a[j]);
        }
    }

    return false;
}

bool tripletSum(int x, int[] a) {
            Dictionary<int, int> hash = new Dictionary<int, int>();
            for (int i = 0; i < a.Length; i++)
            {
                if (hash.ContainsKey(a[i]))hash[a[i]]++;
                else hash[a[i]] = 1;
            }

            for (int i = 0; i < a.Length - 1; i++)
            {
                for (int j = i + 1; j < a.Length; j++)
                {
                    int target = x - (a[i] + a[j]);
                    if (hash.ContainsKey(target))
                    {
                        if (target == a[i] || target == a[j])
                        {

                            if (hash[target] > 1)
                            {
                                return true;
                            }
                        }
                        else
                        {
                            return true;
                                 
                        }
                    }
                }
            }
            return false;
}



 static int higherVersion2(string ver1, string ver2)
        {
            string[] sv1 = ver1.Split('.');
            string[] sv2 = ver2.Split('.');

            for (int i = 0; i < sv1.Length; i++)
            {
                int a = int.Parse(sv1[i]);
                int b = int.Parse(sv2[i]);

                if (a > b)
                {
                    return 1;
                }
                else if (b > a)
                {
                    return -1;
                }

            }
            return 0;
        }

  static char firstNotRepeatingCharacter(string s)
        {
            Dictionary<char, int> dic = new Dictionary<char, int>();
            for (int i = 0; i < s.Length; i++)
            {
                if (dic.ContainsKey(s[i]))
                {
                    dic[s[i]]++;
                }
                else
                {
                    dic[s[i]] = 1;
                }
            }
            for (int i = 0; i < s.Length; i++)
            {
                if (dic[s[i]] == 1) return s[i];
            }
            return '_';
        }


 static int numbersGrouping(int[] a)
        {
            HashSet<int> grupos = new HashSet<int>();
            for (int i = 0; i < a.Length; i++)
            {
                
                grupos.Add( (a[i] - 1) / 10000  );
            }
            return grupos.Count + a.Length ;
        }

     -----------------------------------------  
double factorial(long n)
        {
            double prod = 1;
            for (int i = 2; i <= n; i++)
            {
                prod *= i;
            }
            return prod;
        }

         long deranged(int n)
        {
            double nf = (double) factorial(n);
            double sum = 0;
            for (int k = 0; k <= n; k++)
            {
                sum += (long)Math.Pow(-1, k)/factorial(k) ;
            }
            return (long)(nf * sum);
        }
-------------------------------------------------
static   string words(int arg1)
        {
         https://codefights.com/challenge/d6q43BpSnHhvNPKTE/main
            string answer = "";


            int cen = (arg1 / 100) % 10;
            int dec = (arg1 / 10) % 10;
            int uni = arg1 % 10;

            string[] unidades = { "", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine",
                                "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen" };
            //string[] teen = { "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen" };
            string[] decenas = { "", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety" };
            string[] centenas = {"","one hundred", "two hundred" , "three hundred", "four hundred",
                                     "five hundred", "six hundred", "seven hundred", "eight hundred", "nine hundred"};

            string ns = arg1.ToString();
            

            if (ns.Length >= 2)
            {
                answer += centenas[cen] + " ";
                string sub = ns.Substring(ns.Length-2, 2);

                if (int.Parse(sub) < 10)
                {
                    answer+= unidades[uni];
                }
                else if (int.Parse(sub) < 20)
                {
                    answer += unidades[int.Parse(dec.ToString() + uni.ToString())];
                }
                else
                {
                    answer = centenas[cen] + " " + decenas[dec] + " " + unidades[uni];
                }
                //Console.WriteLine(sub);
            }
            else if (ns.Length < 2)
            {
                answer += unidades[uni];
            }


            return answer.Trim();

        }


static int WordScore(string word)
        {
            int sum = 0;
            for (int i = 0; i < word.Length; i++)
            {
                sum += word[i] - 'a' + 1;
            }
            return sum;
        }

 bool WordSquare(string letters)
        {

            int lenLinea = (int)Math.Sqrt(letters.Length);
            if (lenLinea * lenLinea != letters.Length)
            {
                return false;
            }

            Dictionary<char, int> diccio = new Dictionary<char, int>();
            foreach (char ch in letters)
            {
                if (diccio.ContainsKey(ch))
                {
                    diccio[ch]++;
                }
                else
                {
                    diccio[ch] = 1;
                }
            }

            int unicos = 0;
            int pares = 0;
            foreach (KeyValuePair<char, int> kvp in diccio)
            {
                //if (kvp.Value % 2 != 0)
                //{
                //    if (kvp.Value != 1)
                //    {
                //        return false;
                //    }
                //}
                if (kvp.Value == 1)
                {
                    unicos++;
                }
                if (kvp.Value % 2 == 0)
                {
                    pares += kvp.Value;
                }
            }

            if (unicos > lenLinea)
            {
                return false;
            }
            //if (pares < letters.Length - unicos)
            //{
            //    return false;
            //}

            return true;


        }


static double companyBotStrategy(int[][] trainingData)
        {
            double sum = 0.0;
            double cont = 0;
            for (int i = 0; i < trainingData.Length; i++)
            {
                if (trainingData[i][1] == 1)
                {
                    sum += trainingData[i][0];
                    cont++;
                }
            }
            return sum / cont;
        }



static  int combinePasture(int[] vertices)
        {
           /*
           A (vertices[0], vertices[1])
           B (vertices[2], vertices[3]) 
           X (vertices[4], vertices[5]) 
           Y (vertices[6], vertices[7])
           */

            int izq = Math.Min(vertices[0], vertices[4]);
            int der = Math.Max(vertices[2], vertices[6]);

            int arriba = Math.Max(vertices[3], vertices[7]);
            int abajo = Math.Min(vertices[1], vertices[5]);

            int lado = Math.Max(der - izq, arriba - abajo);
            return lado * lado;
        }

static int[] codefightsTournament(int position, int score)
        {
            return new int[]
            {
                (int)( 2000.0 / Math.Pow( 2.0, position-1)),
                position == 1 ? 2*score : score
            };
        }


static int circleOfNumbers(int n, int firstNumber)
        {
            int mitad = n / 2;

            if (firstNumber < mitad)
            {
                return firstNumber + mitad;
            }
            else
            {
                return firstNumber - mitad;
            }

        }


        static long circleChildren(long k, long m)
        {
            //return (Math.Max(k, m) - Math.Min(k, m)) * 2;
            return Math.Abs(k - m) * 2;
        }


        static int sumRango(int n)
        {
            return (n * (n + 1)) / 2;
        }

        static int checkWeights(int[][] boxes, int packageWeight)
        {
		/*

	You work for a company that makes weights that are used for balancing scales in high school science classes. The weights are shipped in boxes, and each box contains weights in a certain range. Each box is labeled with an array that represents the weights it contains. For example, a box of weights from 4to 12 is labeled [4, 12]. The company never ships the same weight twice in a shipment.
A high school that needs a new set of weights orders a package that consists of several boxes. Once in a while, something goes wrong and either one weight falls off the line, or one weight is accidentally added to one of the boxes. Your job is to check each package before it goes out, and detect if this is the case.
Given the labels of the boxes about to be shipped and the actual packageWeight, you should return:
•	0 if the provided actual packageWeight equals the package weight you would expect according to the label;
•	a if weight a was accidentally added to the package;
•	-a if weight a is missing from the package.
Example
•	For boxes = [[1, 2], [3, 4]] and packageWeight = 10, the output should be
checkWeights(boxes, packageWeight) = 0.
The total expected weight of the package is (1 + 2) + (3 + 4) = 10, which is equal to the packageWeight.
•	For boxes = [[1, 3], [8, 10]] and packageWeight = 35, the output should be
checkWeights(boxes, packageWeight) = 2.
The total expected weight of the package is (1 + 2 + 3) + (8 + 9 + 10) = 33, which means that a weight weighing 2 was accidentally added to the package.
•	For boxes = [[1, 2], [3, 4]] and packageWeight = 6, the output should be
checkWeights(boxes, packageWeight) = -4.
The total expected weight of the weights is (1 + 2) + (3 + 4) = 10, which means that weight 4 is missing from the package.

         */


            long sum = 0;
            for (int i = 0; i < boxes.Length; i++)
            {
                sum += (sumRango(boxes[i][1]) - sumRango(boxes[i][0]-1));
            }

            return (int)(sum - packageWeight);
        }




static bool checkSumSub(int[] arr, int k)
        {

          /*
          You are given an array of integers arr and a target k. Your task is to figure out whether you can pick a subarray of arr such that its elements add up to k.
Example
For arr = [0, 1, 2, 3, 4, 5] and k = 7, the answer should be
checkSum(arr, k) = true.
The sum of the elements of the subarray [3, 4]is exactly 7, so the answer is true.

		*/
           // Dictionary<int, int> map = new Dictionary<int, int>();
            HashSet<int> hs = new HashSet<int>();

            int curr_sum = 0;

            for (int i = 0; i < arr.Length; i++)
            {
                curr_sum += arr[i];

                if (curr_sum == k)
                {
                    return true;
                }

                if (hs.Contains(curr_sum - k))
                {
                    return true;
                }
                hs.Add(curr_sum);
            }
            return false;
        }



static int checksum_part1(long barcode)
        {

         /*
Given the first 11 digits of a GTIN-12 barcode as an integer (i.e. without leading zeros), determine the last number by calculating the value of the check digit.
Example
For a = 29104150021, the output should be
checksum_part1(a) = 9.
The digit sum can be calculated as follows, using the information in the link above:
You know that you need to multiply the digit at N1 by 3, the digit at N2 by 1, and so on, then add these numbers together: 2 * 3 + 9 * 1 + 1 * 3 + 0 * 1 + 4 * 3 + 1 * 1 + 5 * 3 + 0 * 1 + 0 * 3 + 2 * 1 + 1 * 3 = 51
Then, you need to subtract that sum from the nearest equal or higher multiple of ten: 60 - 51 = 9.

*/

            int sum = 0;
            string s = barcode.ToString();

            if (barcode.ToString().Length % 2 == 0)
            {
                for (int i = 0; i < s.Length; i++)
                {
                    if (i % 2 == 0)
                    {
                        sum += (int.Parse(s[i].ToString()) * 3);
                    }
                    else
                    {
                        sum += (int.Parse(s[i].ToString()) * 1);
                    }
                }
            }
            else
            {
                for (int i = 0; i < s.Length; i++)
                {
                    if (i % 2 == 0)
                    {
                        sum += (int.Parse(s[i].ToString()) * 1);
                    }
                    else
                    {
                        sum += (int.Parse(s[i].ToString()) * 3);
                    }
                }
            }

            int nearestMultiple = sum;
            while (nearestMultiple % 10 != 0)
            {
                nearestMultiple++;
            }

            Console.WriteLine(sum + " " + nearestMultiple);
            return nearestMultiple - sum;
        }


static int checkrange(int[] A, int a, int b)
        {
            int ans = 0;
            foreach (int elem in A)
            {
                if (elem >= a && elem <= b)
                {
                    ans++;
                }
            }
            return ans;
        }


static bool checkEqualFrequency(int[] i)
        {

         /*
		Given array of integers, check whether each integer, that occurs in it, is contained there the same number of times as any other integer from the given array.
		Example
		•	For inputArray = [1, 2, 2, 1], the output should be
		checkEqualFrequency(inputArray) = true;
		•	For inputArray = [1, 2, 2, 3, 1, 3, 1, 3], the output should be
		checkEqualFrequency(inputArray) = false.

	*/
            return i.Length % i.Distinct().Count() ==0;

        }


bool Check(std::string N) {
	
      //Check divisibility of N by 11. If N % 11 == 0then the answer is true, otherwise it is false.

	int pares = 0;
	int impares = 0;
	
	for(int i = 0; i < N.length(); i++) {
		
		int dig = (N[i] - '0');
		if(i%2==0 ) {
			pares += dig;
		}else{
			impares += dig;
		}
	}
	
	int resta = pares - impares;
	if(resta == 0 || resta % 11 == 0) {
		return true;
	}
	return false;
}



static string charWeight(string s)
        {

        /*
		Given a string s, your task is to calculate the weight of each character in it, where weight is the number of times a character appears in the string (case insensitive).
The answer should be returned as a string in the format char1{weight1}char2{weight2}..., with the characters sorted as follows:
1.	The characters with larger weights should come first;
2.	In the case of a tie, the characters should be sorted by their char code values in ascending order.
Example
•	For s = "codefights", the output should be
charWeight = "c{1}d{1}e{1}f{1}g{1}h{1}i{1}o{1}s{1}t{1}"
Each character appears in s exactly once, so the characters are sorted by their char codes.
•	For s = "Google", the output should be
charWeight = "g{2}o{2}e{1}l{1}"
The letters 'g' and 'o' both appear twice, so they come first, followed by the other letters.

	*/
            Dictionary<char, int> frec = s.ToLower() .ToCharArray().GroupBy(x => x)
                .ToDictionary(x => x.Key, x => x.Count());

            char[] keys = frec.Keys.ToArray();
            int[] values = frec.Values.ToArray();

            //Array.Sort(values, keys);
            for (int i = 0; i < keys.Length; i++)
            {
                for (int j = i + 1; j < keys.Length; j++)
                {
                    if (values[i] < values[j])
                    {
                        int tempVal = values[i];
                        values[i] = values[j];
                        values[j] = tempVal;

                        char tempKey = keys[i];
                        keys[i] = keys[j];
                        keys[j] = tempKey;
                    }
                    else if (values[i] == values[j])
                    {
                        if (keys[i] > keys[j])
                        {
                            char tempKey = keys[i];
                            keys[i] = keys[j];
                            keys[j] = tempKey;

                        }
                    }

                }

            }

            string res = "";
            for (int i = 0; i < keys.Length; i++)
            {
                res += keys[i] + "{" + values[i] + "}";
            }
            return res;
        }



static int CeilIndex(int[] A, int l, int r, int key)
        {
            while (r - l > 1)
            {
                int m = l + (r - l) / 2;
                if (A[m] >= key)
                    r = m;
                else
                    l = m;
            }

            return r;
        }

        static int LongestIncreasingSubsequenceLength(int[] A, int size)
        {
            // Add boundary case, when array size is one

            int[] tailTable = new int[size];
            int len; // always points empty slot

            tailTable[0] = A[0];
            len = 1;
            for (int i = 1; i < size; i++)
            {
                if (A[i] < tailTable[0])
                    // new smallest value
                    tailTable[0] = A[i];

                else if (A[i] > tailTable[len - 1])
                    // A[i] wants to extend largest subsequence
                    tailTable[len++] = A[i];

                else
                    // A[i] wants to be current end candidate of an existing
                    // subsequence. It will replace ceil value in tailTable
                    tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i];
            }

            return len;
        }

        static int chartFix(int[] chart)
        {
            return chart.Length - LongestIncreasingSubsequenceLength(chart, chart.Length);
        }


------------------------------
static bool charactersRearrangement(string string1, string string2)
        {
            char[] a = string1.ToCharArray();
            char[] b = string2.ToCharArray();

            Array.Sort(a);
            Array.Sort(b);

            return new string(a) == new string(b);

        }


public static void rotate(char[] text, int k)
        {
        
         	
            if (text.Length > 0)
            {

                k = k % text.Length;


                char[] copia = new char[text.Length];

                for (int i = 0; i < text.Length - k; i++)
                {
                    copia[i + k] = text[i];
                }

                for (int i = text.Length - k; i < text.Length; i++)
                {
                    copia[i - (text.Length - k)] = text[i];
                }

                for (int i = 0; i < text.Length; i++)
                {
                    text[i] = copia[i];
                }
            }
        }


        static string changeOfVowelsInCycle(int cycle, string text)
        {

           /*

		Given a text, reverse its characters and shift all of the vowels in a cycle.
The vowels are 'a', 'e', 'i', 'o', and 'u' and can be upper- and lowercase.
Example
For cycle = 1 and text = "potato", the output should be
changeOfVowelsInCycle(cycle, text) = "ototap".
Reversed, the text becomes "otatop". The vowels in the text are 'o', 'a' and 'o' (in this exact order). When shifted by one, they become 'o', 'o' and 'a', so the final answer is "ototap".
	

		*/

            char[] rev = text.ToCharArray();
            Array.Reverse(rev);

            string vocales = "";
            bool[] posvocales = new bool[rev.Length];
            for (int i = 0; i < posvocales.Length; i++)
            {
                if ("aeiouAEIOU".Contains(rev[i]))
                {
                    posvocales[i] = true;
                    vocales += rev[i];
                }
            }

            char[] vocales_rotadas = vocales.ToCharArray();  

              rotate(vocales_rotadas, cycle);
              //Console.WriteLine(new string(vocales_rotadas));
              string ans = "";
             int indice_vocales_rotadas =0;
              for (int i = 0; i < rev.Length; i++)
              {
                  if (posvocales[i])
                  {
                      ans+= vocales_rotadas[indice_vocales_rotadas];
                      indice_vocales_rotadas++;
                  }
                  else
                  {
                      ans += rev[i];
                  }
              }

              return ans;
        }


------------------------------------------------
       string changeCase(string word)
        {
            int lower = 0, upper = 0;

            for (int i = 0; i < word.Length; i++)
            {
                if (char.IsLower(word[i]))
                {
                    lower++;
                }
                else if (char.IsUpper(word[i]))
                {
                    upper++;
                }
            }
            if (lower >= upper)
            {
                return word.ToLower();
            }
            return word.ToUpper();

        }


static string Reemplazar(string text, string old)
        {
            string[] spl = text.Split(' ');

            string[] originales = new string[spl.Length];
            Array.Copy(spl, originales, spl.Length);

            string ans = "";
 
            //foreach (string s in spl)
            for(int i =0; i < spl.Length; i++)
            {
                if (spl[i].ToLower() == old.ToLower())
                {
                    string replace = "";
                    for (int j = 0; j < spl[i].Length; j++)
                    {
                        replace += "*";
                    }
                    ans += replace + " ";
                }
                else
                {
                    ans += originales[i] + " ";
                }

            }
            return ans.Trim();

        }

        static string CensorThis(string text, string[] forbiddenWords)
        {
            foreach (string w in forbiddenWords)
            {
                text = Reemplazar(text, w);
            }
            return text;
        }


------------------------------------
        static string CaPsLoCk(string arg1)
        {
            if (char.IsLower(arg1[0]))
            {
                return char.ToUpper(arg1[0]).ToString();
            }
            return char.ToLower(arg1[0]).ToString();
        }

        bool canYouHearMe(int[] arr)
        {
            double xGirl = arr[0];
            double yGirl = arr[1];

            double range = arr[2];

            double xBrother = arr[3];
            double yBrother = arr[4];

            double dist =
                Math.Sqrt(Math.Pow(xGirl - xBrother, 2) +
                            Math.Pow(yGirl - yBrother, 2));

            return dist <= range; 

        }


        static  bool canLaunch(int numberOfShips)
        {
            int pn = 0;
            for (int n = 1;pn<=numberOfShips ; n++)
            {
                pn = n * (3 * n - 1) / 2;
                if (pn == numberOfShips) return true;
            }
            return false;
        }



----------------------------------------------------------

static void swap(char[][] gameboard, int f1, int c1, int f2, int c2)
        {
            char temp = gameboard[f1][c1];
            gameboard[f1][c1] = gameboard[f2][c2];
            gameboard[f2][c2] = temp;
        }

        static bool isPlayable(char[][] gameboard, int f, int c)
        {
            char actual = gameboard[f][0];
            int cont = 1;
            for (int col = 1; col < gameboard[0].Length; col++)
            {
                if (gameboard[f][col] == actual)
                {
                    cont++;
                    if (cont >= 3)
                    {
                        return true;
                    }
                }
                else
                {
                    cont = 1;
                    actual = gameboard[f][col];
                }
            }

            actual = gameboard[0][c];
            cont = 1;

            for (int fila = 1; fila < gameboard.Length; fila++)
            {
                if (gameboard[fila][c] == actual)
                {
                    cont++;
                    if (cont >= 3)
                    {
                        return true;
                    }
                }
                else
                {
                    cont = 1;
                    actual = gameboard[fila][c];
                }
            }

            return false;
        }

      

        static bool candyCrush3(char[][] gameboard)
        {
            //if (candyCrush1(gameboard)) return true;

            if (isPlayable(gameboard, 0, 0))
            {
                return true;
            }
            for (int i = 0; i < gameboard.Length; i++)
            {
                for (int j = 0; j + 1 < gameboard[i].Length; j++)
                {

                   // 
                    swap(gameboard, i, j, i, j + 1);
                    //MostrarTablero(gameboard);
                    if (isPlayable(gameboard, i, j))
                    {
                        return true;
                    }
                    if (isPlayable(gameboard, i, j+1))
                    {
                        return true;
                    }
                    swap(gameboard, i, j + 1, i, j);
                    //MostrarTablero(gameboard);
                   // MostrarTablero(gameboard);

                }
            }
            for (int j = 0; j < gameboard[0].Length; j++)
            {
                for (int i = 0; i + 1 < gameboard.Length; i++)
                {
                    swap(gameboard, i, j, i + 1, j);
                    // MostrarTablero(gameboard);
                    if (isPlayable(gameboard, i, j))
                    {
                        return true;
                    }
                    if (isPlayable(gameboard, i+1, j))
                    {
                        return true;
                    }

                    swap(gameboard, i + 1, j, i, j);
                    // MostrarTablero(gameboard);
                }
            }
            return false;
        }



---------------------------------------------------
       static  bool candyCrush1(char[][] gameboard)
        {

            for (int i = 0; i < gameboard.Length; i++)
            {
                int j = 0;
                char actual = gameboard[i][j];
                int cont = 0;
                while (j < gameboard[i].Length)
                {
                    if (gameboard[i][j] == actual)
                    {
                        cont++;
                        if (cont >= 3) return true;
                    }
                    else
                    {
                        cont = 1;
                        actual = gameboard[i][j];
                    }

                    j++;
                }
            }

            for (int j = 0; j < gameboard[0].Length; j++)
            {
                int i = 0;
                char actual = gameboard[i][j];
                int cont = 0;
                while (i < gameboard.Length)
                {
                    if (gameboard[i][j] == actual)
                    {
                        cont++;
                        if (cont >= 3) return true;
                    }
                    else
                    {
                        cont = 1;
                        actual = gameboard[i][j];
                    }
                    i++;
                }
            }

            return false;

        }

       static bool candyCrush2(char[][] gameboard, int[] cell, char direction)
       {
           int fila = cell[0];
           int col = cell[1];

           if (direction == 'U')
           {
               char temp = gameboard[fila - 1][col];
               gameboard[fila - 1][col] = gameboard[fila][col];
               gameboard[fila][col] = temp;

           }
           else if (direction == 'D')
           {
               char temp = gameboard[fila + 1][col];
               gameboard[fila + 1][col] = gameboard[fila][col];
               gameboard[fila][col] = temp;
           }
           else if (direction == 'R')
           {
               char temp = gameboard[fila][col + 1];
               gameboard[fila][col + 1] = gameboard[fila][col];
               gameboard[fila][col] = temp;

           }
           else if (direction == 'L')
           {
               char temp = gameboard[fila][col- 1];
               gameboard[fila][col - 1] = gameboard[fila][col];
               gameboard[fila][col] = temp;
           }

           return candyCrush1(gameboard);

       }




static bool candyCrush1(char[][] gameboard)
        {
            for (int i = 0; i < gameboard.Length; i++)
            {
                string fila = new string(gameboard[i]);

                if (fila.Contains("RRR") ||
                    fila.Contains("BBB") ||
                    fila.Contains("GGG") ||
                    fila.Contains("YYY") ||
                    fila.Contains("PPP") ||
                    fila.Contains("OOO"))
                {
                    return true;
                }
            }
            for (int j = 0; j < gameboard[0].Length; j++)
            {
                string col = "";
                for (int i = 0; i < gameboard.Length; i++)
                {
                    col += gameboard[i][j];
                }

                if (col.Contains("RRR") ||
                   col.Contains("BBB") ||
                   col.Contains("GGG") ||
                   col.Contains("YYY") ||
                   col.Contains("PPP") ||
                   col.Contains("OOO"))
                {
                    return true;
                }

            }

            return false;
        }



int candles(int A, int B) {
int burned = 0;
  int leftowers = 0;
  while (A > 0) {
    burned += A;
    leftowers += A;
    A = leftowers / B;
    leftowers %= B;
  }
  return burned;
}

static int candies(int n, int m)
        {
            return (int)(m / n)*n;
        }

        static string caesarian(string message, int n)
        {

            string alfab = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz";
            string ans = "";
            if (n > 0)
            {
                
                 n = n % 26;
                
                
                for (int i = 0; i < message.Length; i++)
                {
                    // ans +=  (alfab.IndexOf(text[i]) + shift).ToString().ToUpper();
                    //ans += alfab[ text.IndexOf(i)+shift];
                    if (char.IsLetter(message[i]))
                    {
                        int indalfab = alfab.IndexOf(message[i]);
                        ans += alfab[indalfab + n].ToString();
                    }
                    else
                    {
                        ans += message[i];
                    }
                }
            }
            else if (n == 0)
            {
                return message;
            }
            else
            {
                n *= -1;
                if (n > 26)
                {
                    n = n % 26;
                }
                n *= -1;


                for (int i = 0; i < message.Length; i++)
                {
                    // ans +=  (alfab.IndexOf(text[i]) + shift).ToString().ToUpper();
                    //ans += alfab[ text.IndexOf(i)+shift];
                    if (char.IsLetter(message[i]))
                    {
                        int indalfab = alfab.LastIndexOf(message[i]);
                        ans += alfab[indalfab + n].ToString();
                    }
                    else
                    {
                        ans += message[i];
                    }
                }
            }
            //Console.WriteLine(ans);
            return ans;
        }


static string Caesar(string text, int shift)
        {
            string alfab = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz";

            if (shift > alfab.Length)
            {
                shift = shift % alfab.Length;
            }

            string ans = "";
            for (int i = 0; i < text.Length; i++)
            {

               // ans +=  (alfab.IndexOf(text[i]) + shift).ToString().ToUpper();
                //ans += alfab[ text.IndexOf(i)+shift];
                if (char.IsLetter(text[i]))
                {
                    int indalfab = alfab.IndexOf(text[i]);
                    ans += alfab[indalfab + shift].ToString().ToUpper();
                }
                else
                {
                    ans += text[i];
                }
            }

            return ans;
        }


static int gcd(int a, int b)
        {
            return b == 0 ? a : gcd(b, a % b);
        }

        static bool breakDown1(int[] arr)
        {
            for(int i =0; i<arr.Length; i++)
            {
                for(int j=i+1; j<arr.Length; j++)
                {
                    if (gcd(arr[i], arr[j]) != 1)
                    {
                        return false;
                    }
                }
            }
            return true;
        }



std::string box(int n) {
       
/*      Given integer n >= 0, draw an n * n square using *'s and spaces. For n = 0, you should return an empty string. There should be no trailing newline*/


        std::string box = "";
        for(int i = 0; i < n-1; i++) {
               
                std::string linea = "";
                for(int j = 0; j < n; j++) {
                       
                        if(i == 0 || j == 0 || i ==n-1 || j == n-1) {
                                linea += "*";
                        }else{
                                linea += " ";
                        }
                }
                box += linea;
                box += "\n";
        }
        for(int j = 0; j < n; j++) {
                box += "*";
        }
       
        return box;
}


static int bowlingScore(int[] rolls)
        {
            int puntos = 0;
            int i;
            for (i = 0; i < rolls.Length; i += 2)
            {
                if (rolls[i] == 10)
                {
                    puntos += 30;

                    if (rolls[i + 1] == 10)
                    {
                        puntos += 30;
                    }
                    else
                    {
                        puntos += rolls[i + 1];
                    }
                }
                else
                {
                    puntos += rolls[i];
                    if(i+1 <rolls.Length) {
                        puntos += rolls[i + 1];
                    }
                }
               // puntos += rolls[i + 1];
            }

            return puntos;
        }
     

   static string[] bottles_of_beer(int n)
        {
            int max = n;

            List<string> res = new List<string>();

            if (n == 1)
            {

                res.Add("1 bottle of beer on the wall, 1 bottle of beer.");
                res.Add("Take one down, pass it around, no more bottles of beer on the wall...");
                res.Add("No more bottles of beer on the wall, no more bottles of beer.");
                res.Add("Go to the store and buy some more, 1 bottle of beer on the wall.");
            }
            else
            {
                for (int i = n; i >= 1; i--)
                {
                    if (i > 1)
                    {
                        res.Add(i + " bottles of beer on the wall, " + i + " bottles of beer.");
                        if (i - 1 > 1)
                        {
                            res.Add("Take one down, pass it around, " + (i - 1) + " bottles of beer on the wall...");
                        }
                        else if (i - 1 == 1)
                        {
                            res.Add("Take one down, pass it around, 1 bottle of beer on the wall...");
                        }
                    }
                    else if (i == 1)
                    {
                        res.Add("1 bottle of beer on the wall, 1 bottle of beer.");
                        res.Add("Take one down, pass it around, no more bottles of beer on the wall...");
                        res.Add("No more bottles of beer on the wall, no more bottles of beer.");
                        res.Add("Go to the store and buy some more, " + max + " bottles of beer on the wall.");
                    }
                }
            }
            return res.ToArray();

        }


int bitwiseandzero(int n, std::vector< int > array) {
 
  int cont = 0;
    for(int i = 0; i < n -  1; i++){
        for(int j = i+1; j < n; j++)
        {
               if((array[i] & array[j]) == 0){
                  cont++;   
                }
                if((array[j] & array[i]) == 0) {
                  cont++;   
                }
        }   
    }
    return cont;
  
}


bool triangleExistence(std::vector<int> sides) {

  struct MyComparator {
    int operator()(int a, int b) {
      return b - a > 0;
    }
  };
  MyComparator c;

  std::sort(sides.begin(), sides.end(), c);

  if (sides[0] + sides[1] > sides[2]) {
    return true;
  }
  return false;
}


std::vector<std::string> textJustification(std::vector<std::string> words, int L) {
 
  std::vector<std::string> text;
  int currentWord = 0;
 
  while (currentWord < words.size()) {
    int left = currentWord;
    int right = left;
    int currentSum = words[left].length();
 
    while (right + 1 < words.size() && currentSum + words[right + 1].length() + 1 <= L) {
      currentSum += words[right + 1].length() + 1;
      right++;
    }
 
    if (left == right) {
      std::string line =  words[left] ;
      for (int i = 0; i < L - words[left].length(); i++) {
        line += " ";
      }
      text.push_back(line);
    } else {
      int freeSpace = L - currentSum;
      int minimalSpaceLen = 1 + freeSpace / (right - left);
      int extraSpaces = freeSpace % (right - left);
      std::string minimalSpace = "";
      for (int i = 0; i < minimalSpaceLen; i++) {
        minimalSpace += " ";
      }
 
      std::string line = "";
      for (int i = left; i < right; i++) {
        line += words[i] + minimalSpace;
        if (extraSpaces > 0) {
          line += " ";
          extraSpaces--;
        }
      }
 
      text.push_back(line + words[right]);
    }
    currentWord = right + 1;
  }
 
  return text;
}



int subarrayCount(std::vector<int> a, int k) {

  int result = 0;
  int left = -1;
  for (int i = 0; i <= a.size(); i++) {
    if (i == a.size() || a[i] <= k) {
      result += (i - left) * (i - left + 1) / 2;
      left = i + 1;
    }
  }

  return result;
}


std::vector<int> splitByValue(int k, std::vector<int> elements) {
  std::vector<int> result;
  for (int i = 0; i < elements.size(); i++) {
    if (elements[i] < k) {
      result.push_back(elements[i]);
    }
  }
  for (int i = 0; i < elements.size(); i++) {
    if (elements[i] >= k) {
      result.push_back(elements[i]);
    }
  }
  return result;
}



std::vector< std::vector<int> > spiralNumbers(int n) {
	std::vector< std::vector<int> > m(n);
	int directions[4][2] = 
	{{0,1}, {1,0}, {0,-1}, {-1,0}},
	currentDirectionIndex = 0,
	currentRow = 0,
	currentColumn = 0,
	currentNum = 1,
	tmpRow,
	tmpColumn;

	for(int i = 0; i < n; i++) {
		std::vector<int> line(n);
		m[i] = line;
	}
	for(int i = n * n; i > 0; i--) {
		//m[currentColumn][currentRow] = currentNum;
		m[currentRow][currentColumn] = currentNum;
		currentNum++;
	
		if(i > 1) {
			while(true) {
				tmpRow = currentRow + 
				 directions[currentDirectionIndex][0];
				tmpColumn = currentColumn +
				 directions[currentDirectionIndex][1];
				if(tmpRow < 0 || tmpRow >= n ||
				   tmpColumn >= n ||
				  m[tmpRow][tmpColumn]) {
					currentDirectionIndex = 
					   (currentDirectionIndex + 1) % 4; 
				} else {
					currentRow = tmpRow;
					currentColumn = tmpColumn;
					break;
				}
			}
		}
	}
	return m;
}



int spiderMove(int X, int Y) {
 
  X =  std::abs(X) ;
  Y = std::abs(Y);
 
  std::vector<int> n(X + 1);
  for(int i = 0; i < X + 1; i++) {
    n[i] = 1;
  }
 
  for (int i = 0; i < Y; i++) {
    for (int j = 1; j < X + 1; j++) {
      n[j] = n[j - 1] + n[j];
    }
  }
  return n[X];
}



int specialPolynomial(int x, int n) {
  int sum = 1,
      lastMonomial = 1,
      k = 0;
  while (sum + lastMonomial * x <= n) {
    lastMonomial *= x;
    sum += lastMonomial;
    k++;
  }
  return k;
}



----------------------------------------------

typedef std::vector<std::string> Array2D;

Array2D sortByLength(Array2D inputArray) {

  for (int i = 0; i < inputArray.size(); i++) {
    int minIndex = i;
    std::string tmp = inputArray[i];
    for (int j = i + 1; j < inputArray.size(); j++) {
      if (inputArray[j].size() < inputArray[minIndex].size()) {
        minIndex = i;
      }
    }
    inputArray[i] = inputArray[minIndex];
    inputArray[minIndex] = tmp;
  }

  return inputArray;
}


int semiprimeByNumber(int n) {

  class Helper {
    Integer[] generatePrimes(int n) {
      int current = 2;
      ArrayList<Integer> primes = new ArrayList<Integer>();

      while (primes.size() < n) {
        boolean isPrime = true;
        for (int i = 2; i * i <= current; i++) {
          if (current % i == 0) {
            isPrime = false;
            break;
          }
        }
        if (isPrime) {
          primes.add(current);
        }
        current++;
      }
      return primes.toArray(new Integer[primes.size()]);
    }
  }
  class MyComparator implements Comparator<Integer> {
    public int compare(Integer a, Integer b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
  }
  Helper h = new Helper();
  Comparator<Integer> comparator = new MyComparator();

  ArrayList<Integer> semiprimes = new ArrayList<Integer>();

  Integer[] primes = h.generatePrimes(n);

  for (int i = 0; i < primes.length; i++) {
    for (int j = i; j < primes.length; j++) {
      semiprimes.add(primes[i] * primes[j]);
    }
  }
  Collections.sort(semiprimes, comparator);

  return semiprimes.get(n - 1);
}



int semiprimeByNumber(int n) {

  struct Helper {
    std::vector<int> generatePrimes(int n) {
      int current = 2;
      std::vector<int> primes;

      while (primes.size() < n) {
        bool isPrime = true;
        for (int i = 2; i * i <= current; i++) {
          if (current % i == 0) {
            isPrime = false;
            break;
          }
        }
        if (isPrime) {
          primes.push_back(current);
        }
        current++;
      }
      return primes;
    }
  };
  Helper h;

  std::vector<int> semiprimes,
                   primes = h.generatePrimes(n);

  for (int i = 0; i < primes.size(); i++) {
    for (int j = i; j < primes.size(); j++) {
      semiprimes.push_back(primes[i] * primes[j]);
    }
  }
  sort(semiprimes.begin(), semiprimes.end());

  return semiprimes[n - 1];
}



bool robotWalk(std::vector<int> a) {
    int minX = 0;
    int minY = -1;
    int maxX = 1000000;
    int maxY = 1000000;
 
    int x = 0;
    int y = 0;
 
    for (int i = 0; i < a.size(); i++) {
        switch (i % 4) {
 
        case 0:
            y += a[i];
            if (y >= maxY) {
                return true;
            }
            maxY = y;
            break;
 
        case 1:
            x += a[i];
            if (x >= maxX) {
                return  true ;
            }
            maxX = x;
            break;
 
        case 2:
            y -= a[i];
            if (y <= minY) {
                return true;
            }
            minY = y;
            break;
 
        case 3:
            x -= a[i];
            if (x <= minX) {
                return true;
            }
            minX = x;
            break;
        }
    }
 
    return false;
}



std::string reflectString(std::string inputString) {

  std::string result = "";
  for (int i = 0; i < inputString.size(); i++) {
    int order = int(inputString[i]) - int('a'),
        reflectedCharCode = int('a') + 25 - order;
    result += char(reflectedCharCode);
  }

  return result;
}



std::string reduceString(std::string inputString) {

 int izq = 0, der = inputString.length() - 1;
    
    while(izq < der && inputString[izq] == inputString[der]){
      izq++;
      der--;   
    }   
    
    //printf("%d %d\n", izq, der);
    if(izq >= der)return "";
    
    return inputString.substr(izq, der - izq + 1);
}



int rectanglesIntersection(std::vector<int> a, std::vector<int> b, std::vector<int> c, std::vector<int> d) {
  std::vector<int> intersection(2);

  for (int i = 0; i < 2; i++) {
    if (a[i] > b[i]) {
      std::swap(a[i], b[i]);
    }
    if (c[i] > d[i]) {
      std::swap(c[i], d[i]);
    }
    if (b[i] < c[i] || d[i] < a[i]) {
      return 0;
    }
    intersection[i] = std::min(b[i], d[i]) - std::max(a[i], c[i]);
  }

  return intersection[0] * intersection[1];
}


int quasifactorial(int n) {
  int answer = 1;
  for (int i = 2; i <= n; ++i) {
    answer *= i;
    --answer;
  }
  return answer;
}


std::string properNounCorrection(std::string noun) {

  struct Helper {
    bool isLowerCase(char symbol) {
      if ('a' <= symbol && symbol <= 'z') {
        return true;
      }
      return false;
    }
  };
  Helper h;

  std::string result = "";

  if (h.isLowerCase(noun[0])) {
    result += noun[0] - 'a' + 'A';
  }
  else {
    result += noun[0];
  }

  for (int i = 1; i < noun.length(); i++) {
    if (!h.isLowerCase(noun[i])) {
      result += noun[i] - 'A' + 'a';
    }
    else {
      result += noun[i];
    }
  }

  return result;
}


bool primeSum(int n, int k) {

  std::vector<int> primes;
  for (int i = 2; i <= n; i++) {
    bool ok = true;
    for (int j = 0; j < (int) primes.size(); j++) {
      if (i % primes[j] == 0) {
        ok = false;
        break;
      }
    }
    if (ok) {
      primes.push_back(i);
    }
  }

  // dp[A][B] is true if number A can be represented
  // as a sum of B prime numbers
  // and false otherwise
  std::vector< std::vector<bool> > dp(n + 1, std::vector<bool>(k + 1));
  dp[0][0] = true;
  for (int b = 1; b <= k; b++) {
    for (int a = 1; a <= n; a++) {
      for (int i = 0; i < (int) primes.size(); i++) {
        int p = primes[i];
        if (a - p >= 0 && dp[a - p][b - 1]) {
          dp[a][b] = true;
        }
      }
    }
  }
  
  return dp[n][k];
}


std::vector<int> prefixSums(std::vector<int> A) {

  std::vector<int> B(1, A[0]);
  for (int i = 1; i < A.size(); i++) {
    B.push_back(B[i - 1] + A[i]);
  }

  return B;
}


std::vector<int> partialSort(std::vector<int> input, int k) {
  std::vector<int> answer;
  int infinity = int(1e9);

  for (int i = 0; i < k; i++) {
    int index = 0;
    for (int j = 0; j < input.size(); j++) {
      if (input[j] < input[index]) {
        index = j;
      }
    }
    answer.push_back(input[index]);
    input[index] = infinity;
  }
  for (int i = 0; i < input.size(); i++) {
    if (input[i] != infinity) {
      answer.push_back(input[i]);
    }
  }

  return answer;
}


int numberOfTriangles2(std::vector<int> sticks) {

  int ans = 0;
  for (int i = 0; i < (int)sticks.size() - 2; i++) {
    for (int j = i+1; j < (int)sticks.size() - 1; j++) {
      int mx = sticks[i] + sticks[j];
      int l = j,
          r = sticks.size();
      while (r - l > 1) {
        int m = (l + r) / 2;
        if (sticks[m] >= mx) {
          r = m;
        } else {
          l = m;
        }
      }
      ans += r - j - 1;
    }
  }

  return ans;
}


int numberOfClans(std::vector<int> divisors, int k) {

  std::vector<bool> masks(1 << divisors.size(), false);
  int res = 0;

  for (int j = 1; j <= k; j++) {
    int mask = 0;
    for (int i = 0; i < divisors.size(); i++) {
      mask *= 2;
      if (j % divisors[i] == 0) {
        mask++;
      }
    }
    masks[mask] = true;
  }

  for (int i = 0; i < (1 << divisors.size()); i++) {
    if (masks[i]) {
      res++;
    }
  }

  return res;
}

int numberOfAnagrams(std::string S) {

  struct Helper {
    int factorial(int n) {
      int prod = 1;
      for (int i = 2; i <= n; i++) {
        prod *= i;
      }
      return prod;
    }
  };
  Helper h;

  std::map<char, int> charCount;

  for(int i = 0; i < S.size(); i++) {
    char key = S[i];
    if (charCount.count(key)) {
      charCount[key]++;
    } else {
      charCount[key] = 1;
    }
  }

  int Mf =  h.factorial(S.length()) ;

  int NFprod = 1;

  for(std::map<char, int>::iterator it = charCount.begin();
      it != charCount.end(); it++) {
    NFprod *= h.factorial(it->second);
  }

  return Mf / NFprod;
}


std::vector<int> nextPermutation(std::vector<int> permutation) {

  for (int i = permutation.size() - 2; i >= 0; i--) {
    if (permutation[i] < permutation[i + 1]) {
      int index = i + 1,
          tmp = permutation[i];
      for (int j = i + 1; j < permutation.size(); j++) {
        if (permutation[j] > permutation[i] && permutation[j] < permutation[index]) {
          index = j;
        }
      }
      permutation[i] = permutation[index];
      permutation[index] = tmp;
      std::vector<int> suffix(permutation.begin() + i + 1, permutation.end());
      std::reverse(suffix.begin(), suffix.end());
      permutation.resize(i + 1);
      permutation.insert(permutation.end(), suffix.begin(), suffix.end());
      return permutation;
    }
  }

  std::sort(permutation.begin(), permutation.end());
  return permutation;
}


typedef std::vector<std::vector<int>> vector2D;

vector2D neighboringCells(vector2D matrix) {

  for (int i = 0; i < matrix.size(); i++) {
    for (int j = 0; j < matrix[0].size(); j++) {
      if (i > 0) {
        matrix[i][j]++;
      }
      if (j > 0) {
        matrix[i][j]++;
      }
      if (i < matrix.size()) {
        matrix[i][j]++;
      }
      if (j + 1 < matrix[0].size()) {
        matrix[i][j]++;
      }
    }
  }
  return matrix;
}


int multisetPermutations(std::vector<int> Multiset) {
 
  std::vector<int> factorials(1, 1);
  for (int i = 1; i <= Multiset.size(); i++) {
    factorials.push_back(factorials[i - 1] * i);
  }
 
  std::sort(Multiset.begin(), Multiset.end());
  std::vector<int> groups(1, 1);
  int i;
  for (i = 1; i < Multiset.size(); i++) {
    if (Multiset[i] == Multiset[i - 1]) {
      groups[(int)groups.size() - 1]++;
    }
    else {
      groups.push_back(1);
    }
  }
 
  int result = factorials[Multiset.size()];
  for (int j = 0; j < groups.size(); j++) {
    result /= factorials[groups[j]];
  }
 
  return result;
}


int mirrorBits(int a) {

  int b = 0;
  while (a >= 1) {
    b <<= 1;
    b |= a & 1;
    a >>= 1;
  }

  return b;
}


std::vector<int> mergeKArrays(std::vector<std::vector<int>> arrays) {
  std::vector<int> firstUnused(arrays.size(), 0),
                   result;
  int n = 0;
  for (int i = 0; i < arrays.size(); i++) {
    n += arrays[i].size();
  }
  for (int i = 0; i < n; i++) {
    int minIndex = -1,
        minValue = 0;
    for (int j = 0; j < arrays.size(); j++) {
      if (firstUnused[j] < arrays[j].size()) {
        if (minIndex == -1 || minValue > arrays[j][firstUnused[j]]) {
          minIndex = j;
          minValue =   arrays[j][firstUnused[j]];
        }
      }
    }
    result.push_back(minValue);
    firstUnused[minIndex]++;
  }
  return result;
}


int maxZeros(int n) {
  int answer = 0,
      maxZeros = 0;
  for (int k = 2; k <= n; k++) {
    int numZeros = 0,
        value = n;
    while (value) {
      if (value % k == 0) {
        numZeros++;
      } 
      value /= k;        
    }
    if (numZeros > maxZeros) {
      maxZeros = numZeros;
      answer = k;
    } 
  }
  return answer;
}


int maxXor(std::vector< int > A) {
	int n = A.size(), best = 0;
  for (int i = 0; i < (1<<n); i++) {
    int x = 0;
    for (int j = 0; j < n; j++) {
      	if (i & (1<<j)) x ^= A[j];
    }
    if (x > best) best = x;
  }
  return best;
}


int maxSubmatrixSum(std::vector<std::vector<int>> matrix,
                    int n, int m) {

  int result = 0;
  for (int i = 0; i + n <= matrix.size(); i++) {
    for (int j =0; j + m <= matrix[0].size(); j++) {
      int sum = 0;
      for (int x = 0; x < n; x++) {
        for (int y = 0; y < m; y++) {
          sum += matrix[i + x][j + y];
        }
      }
      if (i == 0 && j == 0 || sum > result) {
        result = sum;
      }
    }
  }

  return result;
}


std::string longestWord(std::string text) {

  std::string answer = "";
  std::string current = "";

  for (int i = 0; i < text.length(); ++i) {
    if ('a' <= text[i] && text[i] <= 'z'
        || 'A' <= text[i] && text[i] <= 'Z') {
      current += text[i];
      if (current.length() > answer.length()) {
        answer = current;
      }
    } else {
      current = "";
    }
  }

  return answer;
}


int longestSequence(std::vector<int> A)
        {

            int best = 0;
            for (int i = 0; i < A.size(); i++)
            {
                for (int j = i + 1; j < A.size(); j++)
                {
                    int diff = A[j] - A[i];
                    if (diff == 0)
                    {
                        continue;
                    }
                    int cur = 1;
                    int last = A[i];
                    for (int k = j; k < A.size(); k++)
                    {
                        if (A[k] - last == diff)
                        {
                            cur++;
                            last = A[k];
                        }
                    }
                    if (cur > best)
                    {
                        best = cur;
                    }
                }
            }

            return best;
        }

int kthDivisor(int n, int k) {
    
     
    int nDivisor = 0;
    for(int i = 1; i <= n; i++)
    {
        if(n % i ==0){
           nDivisor++;   
        }
        if(nDivisor == k){
           return i;   
        }
        
    }
    
    return -1;
}

bool knightsAndKnaves(std::vector<int> answers) {

  int n = answers.size();
  std::vector<bool> isKnight(n);
  isKnight[0] = true;
  for (int i = 1; i < n; i++) {
    isKnight[i] = answers[0] >> i & 1;
  }
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      if (
          (isKnight[i] == isKnight[j]) ^
          (answers[i] >> j & 1)
      ) {
        return false;
      }
    }
  }

  return true;
}

int knapsackLight(int value1, int weight1,
                  int value2, int weight2, int maxW) {

  if (weight1 + weight2 <= maxW) {
    return value1 + value2;
  }
  if (std::min(weight1, weight2) > maxW) {
    return 0;
  }
  if (weight1 <= maxW && (value1 >= value2 || weight2 > maxW)) {
    return value1;
  }
  return value2;
}

bool isPangram(std::string sentence)
{
    bool letras[26];

    for (int i = 0; i < sentence.size(); i++)
    {
        letras[(int) tolower( sentence[i]) - 'a'] = true;
    }

    for (int i = 0; i < 26; i++) {
        if (!letras[i]) {
          return false;
        }
    }
    return true;
}


bool isOneSwapEnough(std::string inputString) {

  std::vector<std::vector<char>> badPairs(2);
  int badPairsCnt = 0;
  for (int i = 0; i < (int)inputString.size() / 2; i++) {
    char a = inputString[i];
    char b = inputString[inputString.size() - i-1];
    if (a != b) {
      if (badPairsCnt == 2) {
        return false;
      }
      if (a > b) {
        char t = a;
        a = b;
        b = t;
      }
      badPairs[badPairsCnt++] = {a, b};
    }
  }
  if (badPairsCnt == 0) {
    return true;
  } else if (badPairsCnt == 1) {
    if (inputString.size() % 2 == 0) {
      return false;
    }
    char c = inputString[inputString.size() / 2];
    return badPairs[0][0] == c || badPairs[0][1] == c;
  } else {
    return badPairs[0][0] == badPairs[1][0] && badPairs[0][1] == badPairs[1][1];
  }
}


bool isMonotonous(std::vector<int> sequence) {
  if (sequence.size() == 1) {
    return true;
  }
  int direction = sequence[1] - sequence[0];
  for (int i = 0; i < (int)sequence.size() - 1; i++) {
    if (direction * (sequence[i + 1] - sequence[i]) <= 0) {
      return false;
    }
  }
  return true;
}


bool isBeautifulString(std::string inputString) {

  int len = inputString.size();
  for (char sym = 'a'; sym < 'z'; sym++) {
    int balance = 0;
    for (int i = 0; i < len; i++) {
      if (inputString[i] == sym) {
        balance++;
      }
      if (inputString[i] == sym + 1) {
        balance--;
      }
    }
    if (balance < 0) {
      return false;
    }
  }
  return true;
}


std::vector<int> howManyLines(std::vector<int> X, std::vector<int> Y) {

  std::vector<int> result;
  for (int i = 1; i < X.size(); i++) {
    result.push_back(0);
  }
  
  for (int i = 0; i < X.size(); i++) {
    for (int j = i + 1; j < X.size(); j++) {
      int A = Y[i] - Y[j],
          B = X[j] - X[i],
          C = - A * X[i] - B * Y[i],
          countPoints = 0;              
      for (int k = 0; k < X.size(); k++) {
        if (A * X[k] + B * X[k] + C == 0) {
          countPoints++;
        }
      }
      result[countPoints - 2]++;
    }
  }
  for (int i = 0; i < X.size() - 1; i++) {
    result[i] /= (i + 1) * (i + 2) / 2;
  }
  return result;
 }




------------------------------------
typedef std::vector<int> vect;

vect extractMatrixColumn(std::vector<vect> matrix, int column) {

  vect result;
  for (int i = 0; i < matrix.size(); i++) {
    result.push_back(matrix[i][column]);
  }

  return result;
}

static int[][] spiralNumbers(int n)
        {
            int i = 0;
            int j = n;
            int[][] matriz = new int[n][];

            for (i = 0; i < n; i++) matriz[i] = new int[n];
            int num = 1;

            int fila_arriba = 0, fila_abajo = n - 1;
            int col_izq = 0, col_der = n - 1;

            while (fila_arriba <= fila_abajo &&
                col_izq <= col_der)
            {
                for (int k = col_izq; k <= col_der; k++) matriz[fila_arriba][k] = num++;
                fila_arriba++;

                for (int k = fila_arriba; k <= fila_abajo; k++) matriz[k][col_der] = num++;
                col_der--;

                for (int k = col_der; k >= col_izq; k--)  matriz[fila_abajo][k] = num++;
                fila_abajo--;
                
                for (int k = fila_abajo; k >= fila_arriba; k--)  matriz[k][col_izq] = num++;
                col_izq++;
            }

            return matriz;
        }



-----------------------------------------
typedef std::vector<int> vect;

vect extractMatrixColumn(std::vector<vect> matrix, int column) {

  vect result;
  for (int i = 0; i < matrix.size(); i++) {
    result.push_back(matrix[i][column]);
  }

  return result;
}


        static string[] domainType(string[] domains)
        {
            List<string> ans = new List<string>();

            for (int i = 0; i < domains.Length; i++)
            {
                string dom = domains[i];
                int index = dom.LastIndexOf('.');

                string substr = dom.Substring(index, dom.Length - index);

                if (substr == ".org")
                {
                    ans.Add("organization");
                }
                if (substr == ".com")
                {
                    ans.Add("commercial");
                }
                if (substr == ".net")
                {
                    ans.Add("network");
                }
                if (substr == ".info")
                {
                    ans.Add("information");
                }

               // Console.WriteLine(substr);
            }
            return ans.ToArray();
        }




std::vector<std::string> differentSubstrings(std::string input) {
	
	int j = 0;
	std::string subs ;
	std::vector<std::string> lista;
	
	for(int i = 0; i < input.size() - 1; i++) {
		for(int j = i+1; j < input.size(); j++) {
			subs = input.substr(i, j-i);
			lista.push_back(subs);
		}
	}
	
	std::vector<std::string> res;
	std::sort(lista.begin(), lista.end());
	
	for(int i = 1; i < lista.size(); i++) {
		if(lista[i] != lista[i-1] ) {
			res.push_back(lista[i]);
		}
	}
	
	return res;
}


int dfsConnectedComponents(std::vector< std::vector<bool> > matrix) {

  struct Helper {
    std::vector<bool> visited;
    std::vector< std::vector<bool> > matrix;

    void dfs(int currentVertex) {
      visited[currentVertex] = true;
      for (int nextVertex = 0; nextVertex < matrix.size(); nextVertex++) {
        if (matrix[currentVertex][nextVertex] && !visited[nextVertex]) {
          dfs(nextVertex);
        }
      }
    }
  };
  std::vector<bool> visited(matrix.size(), false);
  Helper h;
  h.visited = visited;
  h.matrix = matrix;

  int componentsCount = 0;
  for (int startVertex = 0; startVertex < matrix.size(); startVertex++) {
    if (!h.visited[startVertex]) {
      h.dfs(startVertex);
      componentsCount++;
    }
  }

  return componentsCount;
}



int deleteDigit(int n) {
       
        std::vector<int> digitos;
       
        /* guardo cada digito en un vector */
        while(n > 0 ) {
                digitos.push_back(n%10);
                n/=10;
        }
       
        /* invierto el vector para que quede con el orden original*/
        std::reverse(digitos.begin(), digitos.end());
       
        int max = 0;
        int digElim = 0; /*indice del digito a eliminar */
       
        for(int i = 0; i < digitos.size(); i++) {
 
                int res = 0;
                for(int j = 0; j < digitos.size(); j++) {
                        if(j != digElim) {  /* ignoro el digito a eliminar */
                                res = res * 10 + digitos[j];
                        }
                }
               
                if(res > max) {  
                        max = res;
                }
               
                digElim++; /* incremento el indice del digito a eliminar */
        }
        return max;
}
 


int crossingSum(std::vector<std::vector<int>> matrix,
                int row, int column) {

  int result = 0;
  for (int i = 0; i < matrix.size(); i++) {
    result += matrix[i][column];
  }
  for (int i = 0; i < matrix[0].size(); i++) {
    result += matrix[row][i];
  }
  result -= matrix[row][column];

  return result;
}

int createAnagram(std::string s, std::string t) {

  std::vector<int> cnt1(26, 0);
  std::vector<int> cnt2(26, 0);
  for (int i = 0; i < s.size(); i++) {
    cnt1[s[i] - 'A']++;
    cnt2[t[i] - 'A']++;
  }

  int ans = 0;
  for (int i = 0; i < 26; i++) {
    ans += abs(cnt1[i] - cnt2[i]);
  }

  return ans / 2;
}

typedef std::vector<std::vector<int>> Matrix;
 
Matrix constructSubmatrix(Matrix matrix, std::vector<int> rowsToDelete, std::vector<int> columnsToDelete) {
 
  std::vector<int> line((int)matrix[0].size() - (int)columnsToDelete.size());
  Matrix res((int)matrix.size() - (int)rowsToDelete.size(), line);
  std::vector<bool> useRow(matrix.size(), true);
  std::vector<bool> useColumn(matrix[0].size(), true);
 
  for (int i = 0; i < rowsToDelete.size(); i++) {
    useRow[rowsToDelete[i]] = false;
  }
  for (int i = 0; i < columnsToDelete.size(); i++) {
    useColumn[columnsToDelete[i]] =  false ;
  }
 
  for (int i = 0, i2 = 0; i < matrix.size(); i++) {
    if (useRow[i]) {
      for (int j = 0, j2 = 0; j < matrix[0].size(); j++) {
        if (useColumn[j]) {
          res[i2][j2] = matrix[i][j];
          j2++;
        }
      }
      i2++;
    }
  }
 
  return res;
}


typedef std::vector<std::vector<int>> array2D;
array2D christmasToys(array2D toys) {
  std::queue<int> Queue;
  array2D res = {{}};
  Queue.push(0);
  Queue.push(-1);
 
  while (Queue.size() > 0) {
    int currentToy = Queue.front();
    Queue.pop();
    if (currentToy != -1) {
      res[res.size() - 1].push_back(currentToy);
      for (int i = 0; i < toys[currentToy].size(); i++) {
        Queue.push(toys[currentToy][i]);
      }
        if (Queue.front() == -1 && Queue.size() != 1) {
        Queue.push(-1);
        res.push_back({});
      }
    }
  }
 
  return res;
}


bool checkSameElementExistence(std::vector<int> arr1, std::vector<int> arr2) {
 
  int i = 0,
      j = 0;
  while (i < arr1.size() && j < arr2.size()) {
    if (arr1[i] == arr2[j]) {
      return true;
    }
    if (arr1[i] < arr2[j]) {
      i++;
    } else {
      j++;
    }
  }
 
  return false;
}

bool charactersRearrangement(std::string string1, std::string string2) {
  bool correct = true;

  std::sort(string1.begin(), string1.end());
  std::sort(string2.begin(), string2.end());

  for (int i = 0; i < std::max(string1.length(), string2.length()); ++i) {
    if (i >= string1.length() || i >= string2.length() || string1[i] != string2[i]) {
      correct = false;
      break;
    }
  }

  return correct;
}


int cacheJumping(std::vector<int> history, int user,
                  std::vector<std::string> actions) {

  struct Node {
    int score;
    Node *prev, *next;

    Node(int score) : score(score), prev(nullptr), next(nullptr) { }

    ~Node() {}

    void append(Node *node) {
      next = node;
      node->prev = this;
    }

    void remove() {
      if (prev) {
        prev->next = next;
      }
      if (next) {
        next->prev = prev;
      }
    }
  };

  Node *userNode = nullptr,
      *tailNode = new Node(0);
  for (int i = 0; i < history.size(); i++) {
    tailNode->append(new Node(history[i]));
    tailNode = tailNode->next;
    if (i == user) {
      userNode = tailNode;
    }
  }

  int totalScore = userNode->score;
  for (int i = 0; i < actions.size(); i++) {
    std::stringstream action(actions[i]);
    std::string actionType;
    int x;
    action >> actionType >> x;
    if (actionType == "Open") {
      tailNode->append(new Node(x));
      tailNode = tailNode->next;
    } else {
      userNode->remove();
      if (tailNode == userNode) {
        tailNode = tailNode->prev;
      }
      while (x > 0) {
        if (actionType == "Undo") {
          userNode = userNode->prev;
        } else {
          userNode = userNode->next;
        }
        x--;
      }
      totalScore +=  userNode->score ;
    }
  }

  return totalScore;
}





----------------------------------------------

std::vector<int> arrayCenter(std::vector<int> A) {

  int n = A.size();
  int sumA = A[0],
      minA = A[0];
  for (int i = 1; i < n; i++) {
    sumA += A[i];
    minA = std::min(minA, A[i]);
  }

  std::vector<int> B;
  for (int i = 0; i < n; i++) {
    if (std::abs(n * A[i] - sumA) < n * minA) {
      B.push_back(A[i]);
    }
  }
  return B;
}


static int twoArraysNthElement(int[] array1, int[] array2, int n)
        {
            List<int> ordenado = new List<int>();
            int i = 0, j = 0;
            for ( ; i < array1.Length && j < array2.Length; )
            {
                if (array1[i] < array2[j])
                {
                    ordenado.Add(array1[i]);
                    i++;
                }
                else
                {
                    ordenado.Add(array2[j]);
                    j++;
                }
            }
            while (i < array1.Length)
            {
                ordenado.Add(array1[i]);
                i++;
            }
            while (j < array2.Length)
            {
                ordenado.Add(array2[j]);
                j++;
            }

            return ordenado[n];

        }

static int arrayConversion(int[] inputArray)
        {
            bool flag = false;
            while (inputArray.Length > 1)
            {
                
                List<int> aux = new List<int>();
                //int sum = 0;
                if (!flag && inputArray .Length > 1 )
                {
                    for (int i = 0; i + 1 < inputArray.Length; i+=2)
                    {
                        aux.Add(inputArray[i] + inputArray[i + 1]);
                    }
                }
                else if (inputArray.Length > 1)
                {
                    for (int i = 0; i + 1 < inputArray.Length; i+=2)
                    {
                        aux.Add(inputArray[i] * inputArray[i + 1]);
                    }
                }
                flag = !flag;
                inputArray = aux.ToArray(); 

            }

            return inputArray[0];
        }


std::vector<int> arrayPreviousLess(std::vector<int> items) {

  std::vector<int> result;
  for (int i = 0; i < items.size(); i++) {
    int substitute = -1;
    for (int j = 0; j < i; j++) {
      if (items[j] < items[i]) {
        substitute = items[j];
      }
    }
    result.push_back(substitute);
  }

  return result;
}



int arrayMode(std::vector<int> sequence) {
	
	int cont[11];
	for(int i = 0; i <= 10; i++) cont[i] = 0;
	
	for(int i = 0; i < sequence.size(); i++) {
		cont[sequence[i]]++;
	}
	
	int maxCont = 0, iMax;
	for(int i = 0; i <= 10; i++) {
		if(cont[i] > maxCont) {
			maxCont = cont[i];
			iMax = i;
		}
	}
	
	return iMax;
}


int arrayConversion(std::vector<int> inputArray) {

  int operation = 1;
  while (inputArray.size() > 1) {
    std::vector<int> newArray;
    for (int i = 0; i < inputArray.size(); i += 2) {
      if (operation % 2 == 1) {
        newArray.push_back(inputArray[i] + inputArray[i + 1]);
      }
      else {
        newArray.push_back(inputArray[i] * inputArray[i + 1]);
      }
    }
    inputArray = newArray;
    operation++;
  }

  return inputArray[0];
}

string insertDashes(string inputString) {
	    string[] sp = inputString.Split(' ');
            string ans = "";
            for (int i = 0; i < sp.Length; i++)
            {
                string s = sp[i];
                string aux = "";
                for (int j = 0; j < s.Length; j++)
                {
                    //ans += s[j] + "-";
                    aux += s[j] + "-";
                }
                aux = aux.TrimEnd('-');
                ans += aux + " ";
            }
            return ans.Trim();
}


string[] removeDuplicateStrings(string[] inputArray) {
	    HashSet<string> hash = new HashSet<string>(inputArray);
            return hash.ToArray();
}


int divideAsLongAsPossible(int n, int d) {
            while (n % d == 0)
            {
                n /= d;
            }
            return n;
}

int sequencePeakElement(std::vector<int> sequence) {
  int left = 1;
  int right = (int)sequence.size() - 2;
  while (left < right) {
    int middle = (left + right) / 2;
    if (sequence[middle] > std::max(sequence[middle - 1], sequence[middle + 1])) {
      left = right = middle;
      break;
    }
    if (sequence[middle - 1] < sequence[middle]) {
      left = middle + 1;
    } else {
      right = middle - 1;
    }
  }
  return sequence[left];
}



static int firstMultiple2(int[] divisors, int start)
        {
            for (int i = start; ; i++)
            {
                for (int j = 0; j < divisors.Length; j++)
                {
                    if (i % divisors[j] == 0) return i;
                }

            }


        }


 static int descomponer(int n)
        {
            int sum = 0;
            while (n > 0)
            {
                sum += (n % 10) * (n % 10);
                n /= 10;
            }
            return sum;
        }

        static int squareDigitsSequence(int a0)
        {

            HashSet<int> hash = new HashSet<int>();
            hash.Add(a0);
            int cont = 1;
            do { cont++; } while (hash.Add(a0 = descomponer(a0)));

            return cont;


        }

-------------------------

bool findEqual(int[] sequence) {
	   HashSet<int> hash = new HashSet<int>();

            foreach (int item in sequence)
            {
                if (!hash.Add(item)) return true;
            }
            return false;
}
----------------------

 int cantDivisores(int n)
        {
            int sqr = (int) Math.Sqrt(n);

            int div = 0;
            for (int i = 1; i <= n; i++)
            {
                if (n % i == 0)
                {
                    div++;
                }
            }

            div *= 2;
            if (sqr * sqr == n) div--;
            return div;
        }

        int weekness(int n, int[] cd)
        {
            int debilidad = 0;
            int cantN = cd[n];
            for (int i = n - 1; i >= 1; i--)
            {
                if (cd[i] > cantN)
                {
                    debilidad++;
                }
            }
            return debilidad;
        }

        int[] weakNumbers(int n)
        {
            int[] cd = new int[n + 1];

            for (int i = 1; i <= n; i++)
            {
                cd[i] = cantDivisores(i);
            }

            int max_debilidad = 0;
            int cant_max_debilidad = 0;

            for (int i = 1; i <= n; i++)
            {
                int w = weekness(i, cd);

                if (w > max_debilidad)
                {
                    cant_max_debilidad=1;
                    max_debilidad = w; 
                }
                else if (w == max_debilidad)
                {
                    cant_max_debilidad++;
                }
            }

            return new int[] { max_debilidad, cant_max_debilidad };

        }






-----------------------


bool isPangram(string sentence) {
HashSet<char> hash = new HashSet<char>(sentence.ToLower().ToCharArray());

            for (char ch = 'a'; ch <= 'z'; ch++)
            {
                if (!hash.Contains(ch))
                {
                    return false;
                }
            }
            return true;
}


int[] replaceMiddle(int[] arr) {
 List<int> lista = arr.ToList();
            if (arr.Length %2 ==0)
            {
               
                int medio = arr.Length / 2;
                lista.RemoveAt(medio-1);
                lista.RemoveAt(medio-1);

                int suma = arr[medio - 1] + arr[medio];
                lista.Insert(lista.Count/2, suma);

            }
            return lista.ToArray();
}

def longestWord(text):
    c = ""
    lista = []
    for i in range(0, len(text)):
        if text[i].isalpha():
            c += text[i]
        else:
            if len(c) > 0:
                lista.append(c)
            c = ""
    if len(c) > 0:
        lista.append(c)
        
    maxw = lista[0]    
    for p in lista:
        if len(p ) > len(maxw):
            maxw = p 
    return maxw


bool passwordCheck(string inputString) {
 if (inputString.Length >= 5)
            {
                bool capital = false;
                bool small = false;
                bool digit = false;

                for (int i = 0; i < inputString.Length; i++)
                {
                    if (char.IsUpper(inputString[i]))
                    {
                        capital = true;
                    }
                    if (char.IsLower(inputString[i]))
                    {
                        small = true;
                    }
                    if (char.IsDigit(inputString[i]))
                    {
                        digit = true;
                    }
                }

                return capital && small && digit;
            }
            return false;
}

int magicalWell(int a, int b, int n) {
    	int dollars =0;
	for(int i =0; i<n ; i++) {
		
		dollars += a*b;
		a++;
		b++;
	}
	
	return dollars;
}


bool shefferStroke(bool a, bool b) {
    return !a||!b;
}
bool isSuspiciousRespondent(bool ans1, bool ans2, bool ans3) {
   return ans1 == ans2 && ans2 == ans3;
}


int matrixElementsSum(std::vector<std::vector<int>> matrix) {

  int result = 0;
  for (int i = 0; i < matrix[0].size(); i++) {
    for (int j = 0; j < matrix.size(); j++) {
      if (matrix[j][i] == 0) {
        break;
      }
      result += matrix[j][i];
    }
  }

  return result;
}


int[] powersOfTwo(int n) {
	    List<int> powers = new List<int>();
            for (int i = 0; i <= 30; i++)
            {
                powers.Add((int)Math.Pow(2, i));
            }

            List<int> ans = new List<int>();
            for (int i = powers.Count - 1; i >= 0; i--)
            {
                if(powers[i] <= n)
                {
                    n -= powers[i];
                    ans.Add(powers[i]);
                }
            }
            ans.Sort();
            return ans.ToArray();
}



int[] fibonacciSum(int n) {
	    List<int> lista = new List<int>();
            lista.Add(0);
            lista.Add(1);
            for(int i =2; i<=19; i++)
            {
                lista.Add(lista[i - 1] + lista[i - 2]);
            }

            //foreach(int item in lista)
            //{
            //    Console.WriteLine(item + " ");
            //}

            // return new int[0];
            List<int> ans = new List<int>();
            for(int i = lista.Count - 1; i>=0; i--)
            {
                if(n - lista[i] >= 0)
                {
                    n -= lista[i];
                    if (lista[i] != 0)
                    {
                        ans.Add(lista[i]);
                    }
                }
            }
            ans.Sort();
            return ans.ToArray();
}


int[] extractEachKth(int[] inputArray, int k) {
 List<int> lista = new List<int>();
                
            for(int i =0; i<inputArray.Length; i++)
            {
                if( (i+1) % k !=0)
                {
                    lista.Add(inputArray[i]);
                }
            }

            return lista.ToArray();
}



int digitSum(int n) {
  int sum = 0;
            while(n>0)
            {
                sum += n % 10;
                n /= 10;
            }
            return sum;
}



int neighbouringElements(int[][] a) {
int cont = 0;
            for (int i = 0; i < a.Length; i++)
            {
                for (int j = 0; j < a[i].Length; j++)
                {

                    if (i + 1 < a.Length)
                    {
                        if (a[i][j] == a[i + 1][j])
                        {
                            //hash.Add(i + " " + j + " " + (i + 1) + " " + j);
                            cont++;
                        }
                    }
                    if (j + 1 < a[i].Length)
                    {
                        if (a[i][j] == a[i][j + 1])
                        {
                            //hash.Add(i + " " + j + " " + i + " " + (j + 1));
                            cont++;
                        }
                    }
                }
            }
    


string reflectString(string inputString) {
 StringBuilder sb = new StringBuilder();
            for (int i = 0; i < inputString.Length; i++)
            {
                sb.Append((char)('a' - inputString[i] + 'z'));
            }
            return sb.ToString();
}


bool checkFactorial(int n)
        {
            int prod = 1;
            for (int i = 1; ; i++)
            {
                prod *= i;
                if (prod == n) return true;
                if (prod > n) break;
            }
            return false;
        }
         int leastFactorial(int n)
        {
            for(int i =n;  ; i++)
            {
                if (checkFactorial(i)) return i;
            }
            return 1;
        }

static bool isoscelesTriangle(int[] sides)
        {
            Array.Sort(sides);

            return sides[0] == sides[1] || sides[1] == sides[2];

        }


int differentSymbolsNaive(string s) {
   return new HashSet<char>(s.ToCharArray()).Count;
}


int evenNumbersBeforeFixed(int[] sequence, int fixedElement) {
  if (!sequence.Contains(fixedElement))
            {
                return -1;
            }
            int cont = 0;
            for (int i = 0; i < sequence.Length ; i++)
            {
                if (sequence[i] == fixedElement)
                {
                    break;
                }
                if (sequence[i] % 2 == 0)
                {
                    cont++;
                }
            }
            return cont;
}


  int sumOfCoprimes(int m) {

  int ans = 0;
  for (int p = 2; p <= m; p++) {
    int a = p;
    int b = m;
    while (a > 0) {
      int tmp = b%a;
      b = a;
      a = tmp;
    }

    if (b == 1) {
      ans += p;
    }
  }

  return ans;
}



int[] firstReverseTry(int[] arr) {
     
     if(arr.Length < 2 ) return arr;
     
     int temp = arr[0];
     arr[0] = arr[arr.Length - 1];
     arr[arr.Length - 1] = temp;
     return arr;
}


static int arrayMaximalDifference(int[] inputArray)
        {
            int max_dif = 0;
            for (int i = 0; i < inputArray.Length; i++)
            {
                for (int j = i + 1; j < inputArray.Length; j++)
                {
                    max_dif = Math.Max(max_dif, Math.Abs(inputArray[i] - inputArray[j]));
                }
            }
            return max_dif;
        }



int sumOfTheAngles(int n) {
return  ((n-2) * 180 / n)*n;
}

    static int minimalMultiple(int divisor, int lowerBound) {
        if (lowerBound % divisor == 0) {
            return lowerBound;
        }
        return (lowerBound / divisor + 1) * divisor;
    }




int chessKnight(std::string cell) {
  int row = cell[1] - '0',
      column = cell[0] - 'a' + 1;
  int steps[8][2] = {
      {-2, -1}, {-1, -2}, {1, -2}, {2, -1},
      {2, 1}, {1, 2}, {-1, 2}, {-2, 1}
  };
  int answer = 0;

  for (int i = 0; i < 8; i++) {
    int tmpRow = row + steps[i][0];
    int tmpColumn = column + steps[i][1];
    if (tmpRow >= 1 && tmpRow <= 8 &&
        tmpColumn >= 1 && tmpColumn <= 8) {
      answer++;
    }
  }

  return answer;
}


string capitalizeVowelsRegExp(string input) {
 StringBuilder sb = new StringBuilder();
            for (int i = 0; i < input.Length; i++)
            {
                if ("aeiouy".Contains(input[i]))
                {
                    sb.Append(char.ToUpper(input[i]));
                }
                else{
                   sb.Append(input[i]);  
                }
            }
            return sb.ToString();
}



static  int smallestNumber(int n)
        {
            return int.Parse("1" + new string('0', n - 1));
        }

int ballsDistribution(int colors, int ballsPerColor, int boxSize) {
	    int suma = 0;
            int ans = 0;

            for (int i = 0; i < colors; i++)
            {
                bool flag = false;
                for (int j = 0; j < ballsPerColor; j++)
                {
                    suma++;
                    if (suma % boxSize == 0)
                    {
                        flag = true;
                    }
                    else if (flag)
                    {
                        ans++;
                        flag = false;
                    }

                }
            }

            return ans;
}



int numberOfEvenDigits(int n) {
	   int cont = 0;
            foreach (char ch in n + "")
            {
                if ((ch - '0') % 2 == 0)
                {
                    cont++;
                }
            }
            return cont;
}


string htmlEndTagByStartTag(string startTag) {
      string primer = startTag.Split(' ')[0].TrimEnd('>').TrimEnd('>');
            return primer.Insert(1, "/") + ">";
}


bool isSumOfConsecutive(int n) {
  for (int start = 1; start < n; start++) {
    int number = n,
        subtrahend = start;
    while (number > 0) {
      number -= subtrahend;
      subtrahend++;
    }
    if (!number) {
      return true;
    }
  }
  return false;
} 

static bool triangleExistence(int[] sides)
        {
            Array.Sort(sides);
            return sides[0] + sides[1] >= sides[2];
        }



int binarySearch(int[] inputArray, int searchElement) {

  int minIndex = -1;
  int maxIndex = inputArray.length;
  int currentIndex;
  int currentElement;

  while (minIndex < maxIndex - 1) {
    currentIndex = (minIndex + maxIndex) / 2;
    currentElement = inputArray[currentIndex];

    if (currentElement < searchElement) {
      minIndex = currentIndex;
    } else {
      maxIndex = currentIndex;
    }
  }

  if (maxIndex == inputArray.length || inputArray[maxIndex] != searchElement) {
    return -1;
  }
  return maxIndex;
}


def isDivisibleBy3(inputString):

    digitSum = 0
    leftBound = ord('0')
    rightBound = ord('9')
    answer = []
    mask = list(inputString)
    asteriskPos = -1

    for i in range(len(mask)):
        if (leftBound <= ord(mask[i]) and
          ord(mask[i]) <= rightBound):
            digitSum += ord(mask[i]) - leftBound
        else:
            asteriskPos = i

    for i in range(10):
        if (digitSum + i) % 3 == 0:
            mask[asteriskPos] = chr(leftBound + i)
            answer.append(''.join(mask))

    return answer




int maxGCD(std::vector<int> sequence) {
  struct Helper {
    int gcd(int a, int b) {
      if (b == 0) {
        return a;
      }
      return gcd(b, a % b);
    }
  };

  Helper h;
  int bestRes = 0;

  for (int i = 0; i < sequence.size(); i++) {
    int result = sequence[0];
    if (i == 0) {
      result = sequence[1];
    }
    for (int j = 0; j < sequence.size(); j++) {
      if (i == j) {
        continue;
      }
      result = h.gcd(result, sequence[j]);
    }
    if (result > bestRes) {
      bestRes = result;
    }
  }

  return bestRes;
}


int dotProduct(int[] v1, int[] v2) {
int sum = 0;
            for (int i = 0; i < v1.Length; i++)
            {
                sum += v1[i] * v2[i];
            }
            return sum;
}

int countWays(int n, int k) {

  ArrayList<ArrayList<Integer>> c_nk = new ArrayList<>();
  for (int i = 0; i <= n; i++) {
    c_nk.add(new ArrayList<Integer>());
    for (int j = 0; j <= k; j++) {
      c_nk.get(i).add(0);
    }
  }
  c_nk.get(0).set(0, 1);
  for (int i = 0; i < n; i++) {
    ArrayList<Integer> cur = c_nk.get(i);
    ArrayList<Integer> next = c_nk.get(i + 1);
    for (int j = 0; j <= k; j++) {
      if (i + 1 <= n) {
        next.set(j, next.get(j) + cur.get(j));
        if (j + 1 <= k) {
          next.set(j + 1, next.get(j + 1) + cur.get(j));
        }
      }
    }
  }

  return  c_nk.get(n).get(k) ;
}



String alphabeticShift(String inputString) {
  StringBuilder chars = new StringBuilder();
  for (int i = 0; i < inputString.length(); ++i) {
    int number = inputString.charAt(i)-'a';
    number = (number + 1) % 26;
    chars.append((char) ('a' + number));
  }
  return chars.toString();
}


int extraNumber(int a, int b, int c) {
if (a != b && a != c)
            {
                return a;
            }
            if (b != a && b != c)
            {
                return b;
            }
            return c;
}

bool isCorrectSentence(string inputString)
        {
            if (!char.IsLetter(inputString[0]))
            {
                return false;
            }
            if (char.IsLower(inputString[0]))
            {
                return false;
            }
            if (inputString[inputString.Length - 1] != '.')
            {
                return false;
            }
            return true;
        }


 static int sumOfDivisors(int n)
        {
            int sum = 0;
            for (int i = 1; i * i <= n; i++)
            {
                if (n % i == 0)
                {
                    if (n / i == i)
                    {
                        sum += i;
                    }
                    else
                    {
                        sum += i;
                        sum += (n / i);
                    }
                }
            }

            return sum;

        }

bool rightTriangle(int[] sides)
        {
            Array.Sort(sides);

            return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2];

        }

static int[] arrayReplace(int[] inputArray, int elemToReplace, int substitutionElem)
        {

            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i] == elemToReplace)
                {
                    inputArray[i] = substitutionElem;
                }

            }
            return inputArray;
        }


static string integerToStringOfFixedWidth(int number, int width)
        {
            string s = number + "";

            if (width > s.Length)
            {
                return new string('0', width - s.Length) + s;
            }

            return s.Substring(s.Length - width);

        }


string fromDecimal(int b, int n) {
string s = "";
            while (n > 0)
            {
                 s= s.Insert(0, (n % b)+"");
                n /= b;
            }
            return s;
}



static int shapeArea(int n)
        {
            int sum = 0;
            int fila = 1;
            for (int i = 1; i < n; i++)
            {
                sum += fila*2;
                fila += 2;
            }
            sum += fila;
            return sum;
        }


 static int arrayMinimumAboveBound(int[] inputArray, int bound)
        {
            int minAboveBound = -51;
            int min_dif = int.MaxValue;
            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i] > bound)
                {
                    int dif = inputArray[i] - bound;
                    if (dif < min_dif)
                    {
                        min_dif = dif;
                        minAboveBound = inputArray[i];
                    }
                }
            }
            return minAboveBound;
        }

int[] arrayPreviousLess(int[] items) {
            List<int> lista = new List<int>();
            lista.Add(-1);
            for (int i = 1; i < items.Length; i++)
            {
                int j = i - 1;
                for (; j >= 0; j--)
                {
                    if (items[j] < items[i])
                    {
                        lista.Add(items[j]);
                        break;
                    }
                }
                if (j < 0) lista.Add(-1);
            }
            return lista.ToArray();
}


int sameElementsNaive(int[] a, int[] b) {
    HashSet<int> hash = new HashSet<int>(b);

            int ans = 0;
            for (int i = 0; i < a.Length; i++)
            {
                if (hash.Contains(a[i]))
                {
                    ans++;
                }
            }
            return ans;
}


 static bool isOneSwapEnough(string inputString)
        {
            char[] ch = inputString.ToCharArray();

            for (int i = 0; i < ch.Length; i++)
            {
                for (int j = i + 1; j < ch.Length; j++)
                {
                    char temp = ch[i];
                    ch[i] = ch[j];
                    ch[j] = temp;

                    int k = 0, l = ch.Length - 1;
                    bool es_palin = true;
                    while (k < l)
                    {
                        if (ch[k] != ch[l])
                        {
                            es_palin = false;
                            break;
                        }
                        k++;
                        l--;
                    }

                    if (es_palin) return true;

                    temp = ch[i];
                    ch[i] = ch[j];
                    ch[j] = temp;
                }
            }

            return false;
        }



 static bool alternatingSort(int[] a)
        {
            if (a.Length <= 1) return true;

            List<int> alter = new List<int>();

            int i = 0, j = a.Length - 1;

            while (i <= j)
            {
                if (i != j)
                {
                    alter.Add(a[i]);
                    alter.Add(a[j]);

                }
                else
                {
                    alter.Add(a[i]);
                }
                i++;
                j--;
            }

            for (i = 1; i < alter.Count; i++)
            {
                if (alter[i - 1] >= alter[i])
                {
                    return false;
                }
            }
            return true;

        }




        static int[] mutateTheArray(int n, int[] a)
        {
            int[] b = new int[n];

            for (int i = 0; i < n; i++)
            {
                int sum = 0;
                if (i - 1 >= 0)
                {
                    sum += a[i - 1];
                }
                if (i + 1 < n)
                {
                    sum += a[i + 1];
                }
                sum += a[i];
                b[i] = sum;
            }
            return b;
        }



 static int differentDigitsNumberSearch(int[] inputArray)
        {

            for (int i = 0; i < inputArray.Length; i++)
            {
                HashSet<int> digitos = new HashSet<int>();

                int copia = inputArray[i];
                while (copia > 0)
                {
                    if (!digitos.Add(copia % 10))
                    {
                        break;
                    }
                    copia /= 10;
                }
                if (copia == 0) return inputArray[i];

            }
            return -1;
        }


--------------------------


int[][] create2DArray(int[] lengths) {
	   int[][] output =
                new int[lengths.Length][];

            for (int i = 0; i < lengths.Length; i++)
            {
                output[i] = new int[lengths[i]];
                for (int j = 0; j < lengths[i]; j++)
                {
                    output[i][j] = j;
                }
            }
            return output;
}

string whoseMove(string lastPlayer, bool win)
        {
            

            if (win)
            {
                return lastPlayer;
            }

            if (lastPlayer == "black") return "white";
            return "black";

        }


 static string reduceString(string inputString)
        {

            int i = 0;
            int j = inputString.Length - 1;

            while (i <= j)
            {
                if (inputString[i] == inputString[j])
                {

                    i++;
                    j--;
                }
                else
                {
                    break;
                }
            }
            if (j <= i) return "";

            return inputString.Substring(i, j - i + 1);

        }

 static int countWaysToChangeDigit(int value)
        {
            string s = value + "";
            int sum = 0;
            for (int i = 0; i < s.Length; i++)
            {

                sum += 9 - (s[i] - '0');
            }
            return sum;
        }



    static void revertir(char[] ch, int desde, int hasta)
        {

            int i = desde, j = hasta;

            while (i < j)
            {
                char temp = ch[i];
                ch[i] = ch[j];
                ch[j] = temp;
                i++;
                j--;

            }
        }


        static  string reverseInParentheses(string s)
        {

            char[] ch = s.ToCharArray();

            Stack<int> pila = new Stack<int>();
            for (int i = 0; i < ch.Length; i++)
            {
                if ( ch[i] == '(')
                {
                    pila.Push(i);

                }
                else
                {
                    if (ch[i] == ')')
                    {
                        revertir(ch, pila.Peek(), i );
                        pila.Pop();
                    }
                }
            }

            //return new string(ch);
            string ans = "";
            for (int i = 0; i < ch.Length; i++)
            {
                ans += ch[i] != '(' && ch[i] != ')' ? ch[i]+"" : "";
            }
            return ans;
        }


 

static int[] sortByHeight(int[] a)
        {

            List<int> nums = new List<int>( );
            for (int i = 0; i <a.Length; i++) if (a[i] != -1)nums.Add(a[i]); 
            nums.Sort();
            int k = 0;
            for (int i = 0; i < a.Length; i++) if (a[i] != -1) a[i] = nums[k++];

            return a;
        }



static bool isLucky(int n)
        {
            string s = n + "";
             
            int a = 0, b = 0;
            for (int i =0; i < s.Length / 2; i++)
            {
                a += (s[i] - '0');
                b += (s[i + s.Length / 2 ] - '0');
            }

            return a == b;
        }

std::vector<int> maxSumSegments(std::vector<int> inputArray) {

  std::vector<int> result;
  for (int i = 1; i <= inputArray.size(); i++) {
    int sum = 0,
        mxSum = 0,
        index = -1;
    for (int j = 0; j < inputArray.size(); j++) {
      sum += inputArray[j];
      if (j >= i) {
        sum -= inputArray[j - i];
      }
      if (j >= i - 1 && (index == -1 || sum > mxSum)) {
        mxSum = sum;
        index = j-i+1;
      }
    }
    result.push_back(index);
  }
  return result;
}

  static string[] allLongestStrings(string[] inputArray)
        {
            int max_len = 0;
            List<string> all = new List<string>();
            for (int i = 0; i < inputArray.Length; i++)
            {
                
                if (inputArray[i].Length == max_len)
                {
                    all.Add(inputArray[i]);
                }
                else if (inputArray[i].Length > max_len)
                {
                    max_len = inputArray[i].Length;
                    all = new List<string>();
                    all.Add(inputArray[i]);
                }
            }
            return all.ToArray();
        }

int arrayMaxConsecutiveSum(std::vector<int> inputArray, int k) {

  int result = 0,
      currentSum = 0;

  for (int i = 0; i < k-1; i++) {
    currentSum += inputArray[i];
  }
  for (int i = k - 1; i < inputArray.size(); i++) {
    currentSum += inputArray[i];
    if (currentSum > result) {
      result = currentSum;
    }
    currentSum -= inputArray[i - k + 1];
  }

  return result;
}





int maxDigit(int n) {
            int max = 0;
            while (n > 0)
            {
                max = Math.Max(max, n % 10);
                n /= 10;
            }
            return max;
}


int axisAlignedBoundingBox(std::vector<int> x, std::vector<int> y) {

  int minX = x[0],
      maxX = x[0],
      minY = y[0],
      maxY = y[0];

  for (int i = 1; i < x.size(); i++) {
    minX = std::min(x[i], minX);
    maxX = std::max(x[i], maxX);
    minY = std::min(y[i], minY);
    maxY = std::max(y[i], maxY);
  }

  return (maxX - minX) * (maxY - minY) ;
}

int[] prefixSums(int[] a) {
	    int[] b = new int[a.Length];
            b[0] = a[0];
            for (int i = 1; i < a.Length; i++)
            {
                b[i] = a[i] + b[i - 1];
            }
            return b;
}



boolean regularBracketSequence2(String sequence) {

  LinkedList<Character> stack = new LinkedList<>();
  for (int i = 0; i < sequence.length(); i++) {
    if (stack.size() > 0
        && stack.getLast() == '(' && sequence.charAt(i) == ')') {
      stack.pollLast();
      continue;
    }
    if (stack.size() > 0
        && stack.getLast() == '[' && sequence.charAt(i) == ']') {
      stack.pollLast();
      continue;
    }
    stack.addLast(sequence.charAt(i));
  }

  if (stack.size() != 0) {
    return false;
  }
  return true;
}


string properNounCorrection(string noun) {
return char.ToUpper(noun[0]) + noun.Substring(1).ToLower();
}



  static int maxZeros(int n)
        {
            int max_z = 0;
            int max_base = -1;
            for (int b = 2; b <= 10; b++)
            {
                int zeros = 0;
                int c = n;
                while (c > 0)
                {
                    if (c % b == 0)
                    {
                        zeros++;
                    }
                    c /= b;
                }
                //max_z = Math.Max(max_z, zeros);
                if (zeros > max_z)
                {
                    max_base = b;
                    max_z = zeros;
                    //Console.WriteLine(b + " " + zeros);
                }
            }
            return max_base;
        }


int josephusProblem(int n, int k) {

  boolean[] removed = new boolean[n];
  int currentPerson = 0;

  for (int i = 1; i < n; i++) {
    int skipped = 0;
    while (skipped < k - 1) {
      if (!removed[currentPerson]) {
        skipped++;
      }
      currentPerson = (currentPerson + 1) % n;
    }
    while (removed[currentPerson]) {
      currentPerson = (currentPerson + 1) % n;
    }
    removed[currentPerson] = true;
  }

  for (int i = 0; i < n; i++) {
    if (!removed[i]) {
      return i + 1;
    }
  }
  return 0;
}

typedef std::vector<std::vector<int>> Matrix;

Matrix constructSubmatrix(Matrix matrix,
                          std::vector<int> rowsToDelete,
                          std::vector<int> columnsToDelete) {

  std::vector<int> line((int)matrix[0].size() - (int)columnsToDelete.size());
  Matrix res((int)matrix.size() - (int)rowsToDelete.size(), line);
  std::vector<bool> useRow(matrix.size(), true);
  std::vector<bool> useColumn(matrix[0].size(), true);

  for (int i = 0; i < rowsToDelete.size(); i++) {
    useRow[rowsToDelete[i]] = false;
  }
  for (int i = 0; i < columnsToDelete.size(); i++) {
    useColumn[columnsToDelete[i]] = false;
  }

  for (int i = 0, i2 = 0; i < matrix.size(); i++) {
    if (useRow[i]) {
      for (int j = 0, j2 = 0; j < matrix[0].size(); j++) {
        if (useColumn[j]) {
          res[i2][j2++] = matrix[i][j];
        }
      }
      i2++;
    }
  }

  return res;
}




 int[] zFunctionNaive(string s)
        {
            int[] r = new int[s.Length];
            for (int i = 0; i < s.Length; i++)
            {
                int j = 0;
                while (i + j < s.Length && s[i + j] == s[j])
                {
                    j++;
                }
                r[i] = anz;
            }
            return r;
        }

int avoidObstacles(int[] inputArray) {

  for (int i = 1; ; i++) {
    for (int j = 0; j < inputArray.length; j++) {
      if (inputArray[j] % i == 0) {
        break;
      }
      if (j == inputArray.length-1) {
        return i;
      }
    }
  }
}


int[] mixedFractionToImproper(int[] a) {
    int[] b=new int[2];
    b[0]=a[0]*a[2]+a[1];
    b[1]=a[2];
    return b;
}


int mySqrt(int n) {

  int left = 1, right = n + 1;
  while (left + 1 < right) {
    int middle = left + 1;
    if (middle * middle <= n) {
      left = middle;
    }
    else {
      right = middle;
    }
  }

  return left;
}

int arrayMaximalAdjacentDifference(int[] inputArray) {
int max =0;
            for (int i = 0; i + 1< inputArray.Length; i++)
            {
                max = Math.Max(Math.Abs(inputArray[i] - inputArray[i + 1]), max);
            }
            return max;
}

bool isOneSwapEnough(string inputString) {
   char[] ch = inputString.ToCharArray();

            char[] rev = new char[ch.Length];
            Array.Copy(ch, rev, ch.Length);
            Array.Reverse(rev);

            if (new string(ch) == new string(rev))
            {
                return true;
            }

            for (int i = 0; i < ch.Length - 1; i++)
            {
                for (int j = i + 1; j < ch.Length; j++)
                {
                    char temp = ch[i];
                    ch[i] = ch[j];
                    ch[j] = temp;

                    rev = new char[ch.Length];
                    Array.Copy(ch, rev, ch.Length);
                    Array.Reverse(rev);

                    if (new string(ch) ==  new  string( rev))
                    {
                        return true;
                    }
                    temp = ch[j];
                    ch[j] = ch[i];
                    ch[i] = temp;
                }
            }

            return false;
}





bool increaseNumberRoundness(int n) {

  bool gotToSignificant = false;
  while (n > 0) {
    if (n % 10 == 0 && gotToSignificant) {
      return true;
    } else if (n % 10 != 0) {
      gotToSignificant = true;
    }
    n /= 10;
  }

  return false;
}


std::string whoseMove(std::string lastPlayer, bool win) {
   if (win)
      return lastPlayer;
   if (lastPlayer=="white")
      return "black";
   return "white";
}


int rounders(int n) {
 string s = n + "";
            char[] ch = s.ToCharArray();
            int i = s.Length - 1;

            while (i > 0)
            {
                if (ch[i] < '5')
                {
                    ch[i] = '0';

                }
                if (ch[i] >= '5')
                {
                    if (i - 1 >= 0)
                    {
                        ch[i] = '0';
                        if (ch[i - 1] + 1 <= '9')
                        {
                            ch[i - 1]++;
                        }
                        else
                        {
                            ch[i - 1] = '0';
                            return int.Parse("1" + new string(ch));
                        }
                    }
                    
                }
                i--;
            }

            return int.Parse(new string(ch));
}




static int[] arrayPreviousLess(int[] items)
        {
            int[] ans = new int[items.Length];
            for (int i = 0; i < items.Length; i++)
            {
                int j;
                for ( j = i - 1; j >= 0; j--)
                {
                    if (items[j] < items[i])
                    {
                        ans[i] = items[j];
                        break;
                    }
                }
                if (j == -1)
                {
                    ans[i] = -1;
                }
            }

            return ans;
        }

int axisAlignedCirclesBoundingBox(int[] x, int[] y, int[] r) {
int minX = x[0] - r[0],
                maxX = x[0] + r[0],
                minY = y[0] - r[0],
                maxY = y[0] + r[0];

            for (int i = 1; i < x.Length; i++)
            {
                minX = Math.Min(x[i] - r[i], minX);
                maxX = Math.Max(x[i] + r[i], maxX);
                minY = Math.Min(y[i] - r[i], minY);
                maxY = Math.Max(y[i] + r[i], maxY);
            }

            return (maxX - minX) * (maxY - minY);
}

 int gcd(int a, int b)
        {
            if (b == 0)
                return a;
            return gcd(b, a % b);

        }

          int[] fractionMultiplication(int[] a, int[] b)
        {
            int num = a[0] * b[0];
            int den = a[1] * b[1];

            int g = gcd(num, den);
            return new int[] { num / g, den / g };

        }


bool coolString(string s) {
 
             if (s.Length == 1 && char.IsLetter(s[0])) return true;


            s = s.Replace(" ", "").Trim();

            bool contiene_letra = false;

            for (int i = 0; i + 1 < s.Length; i++)
            {
                if (char.IsLetter(s[i]) && char.IsLetter(s[i + 1]))
                {
                    if (char.IsLower(s[i]) && char.IsLower(s[i + 1]))
                    {
                        return false;
                    }
                    if (char.IsUpper(s[i]) && char.IsUpper(s[i + 1]))
                    {
                        return false;
                    }
                    contiene_letra = true;
                }
                else
                {
                    return false;
                }
            }

            if (!contiene_letra) return false;

            return true;

}



bool sameDigitNumber(int n) {
string s = n+"";
            char actual = s[0];

            for (int i = 1; i < s.Length; i++)
            {
                if (s[i] != actual) return false;
            }
            return true;
}




function reversedSumOfDigits(p, n) {
    if (!p && 1 === n) return '0';
    if (9 * n < p || !p) return '-1';

    const result = [];
    for (let i = 0; n - 1 > i; ++i) {
        const a = 9 < (p - 1) ? 9 : (p - 1);
        p -= a;
        result.unshift(a);
    }
    return p + result.join('');
}


 int gcd(int a, int b)
        {
            if (b == 0)
                return a;
            return gcd(b, a % b);

        } 
         int eulersTotientFunction(int n)
        {
            int ans = 0;
            for (int i = 1; i <= n; i++)
            {
                if (gcd(i, n) == 1)
                {
                    ans++;
                }
            }
            return ans;
        }



String mySubstring(String i, int l, int r) {
    return i.substring(l,r+1);
}


int candies(int n, int m) {
    int eat = m % n;
    return m-eat;
}

int polygonPerimeter(bool[][] matrix) {
int p = 0;
            for (int i = 0; i  < matrix.Length; i++)
            {
                for (int j = 0; j  < matrix[i].Length; j++)
                {
                    if (j+1 < matrix[i].Length && matrix[i][j] != matrix[i][j + 1])
                    {
                        p++;
                    }
                    if ( i+1 < matrix.Length && matrix[i][j] != matrix[i + 1][j])
                    {
                        p++;
                    }
                    if (matrix[i][j]) //bordes
                    {
                        if (i - 1 < 0) p++;
                        if (i + 1 >= matrix.Length) p++;
                        if (j - 1 < 0) p++;
                        if (j + 1 >= matrix[i].Length) p++;
                    }
                }
            }
            return p;
}



int findSquareSide(int[] x, int[] y) {
        class Helper {
            int sqr(int x) {
                return x * x;
            }

            int squareDistance(int[] a, int[] b) {
                return sqr(a[0] - b[0]) + sqr(a[1] - b[1]);
            }

            int[] point(int x, int y) {
                return new int[]{x, y};
            }
        }
        Helper h = new Helper();

        int answer = h.squareDistance(h.point(x[0], y[0]), h.point(x[1], y[1]));
        for (int i = 2; i < 4; i++) {
            answer = Math.min(answer,
                    h.squareDistance(h.point(x[i - 1], y[i - 1]),
                            h.point(x[i], y[i])));
        }
        return answer;
}


int[] inversePermutation(int[] permutation) {
           int[] ans = new int[permutation.Length];

            for (int i = 0; i < permutation.Length; i++)
            {
                ans[permutation[i]-1] = i+1;
            }
            return ans;
}


function parabole(a, b, c, x) {
    return a * x ** 2 + b * x + c
}

bool reverseToSort(int[] inputArray) {
	    for (int i = 0; i < inputArray.Length - 1; i++)
            {
                for (int j = i + 1; j < inputArray.Length; j++)
                {
                    int k = i, l = j;

                    while (k < l)
                    {
                        int temp = inputArray[k];
                        inputArray[k] = inputArray[l];
                        inputArray[l] = temp;
                        k++;
                        l--;
                    }
                    bool ordenado = true;
                    for (int m = 0; m + 1< inputArray.Length; m++)
                    {
                        //Console.Write(inputArray[m] + " ");
                        if (inputArray[m + 1] <= inputArray[m])
                        {
                            ordenado = false;
                            break;
                        }
                    }

                    if (ordenado) return true;

                    //Console.WriteLine();
                    k = i; l = j;

                    while (k < l)
                    {
                        int temp = inputArray[k];
                        inputArray[k] = inputArray[l];
                        inputArray[l] = temp;
                        k++;
                        l--;
                    }
                }
                
            }

            return false;
}


int absoluteValuesSumMinimization(int[] a) {

  int indexOfMinimum = -1;
  int minimalSum = Integer.MAX_VALUE;

  for (int i = 0; i < a.length; i++) {
    int sum = 0;
    for (int j = 0; j < a.length; j++) {
      sum += Math.abs(a[j] - a[i]);
    }
    if (sum < minimalSum) {
      indexOfMinimum = i;minimalSum=sum;
    }
  }

  return a[indexOfMinimum];
}



int[] threeAndFour(int n) {
    
    List<int> arr = new List<int>();
    for(int i =0; i<=n; i++) {
        
        if(i%3 ==0 && i%4 ==0) {
            arr.Add(i);   
        }
    }
    return arr.ToArray();
}


void mergeArrays(std::vector<int> &sequence, int left, int middle, int right) {
  std::vector<int> result;
  int i, j;

  for (i = left, j = middle; i < middle && j < right; ) {
    if (sequence[i] < sequence[j]) {
      result.push_back(sequence[i]);
      i++;
    }
    else {
      result.push_back(sequence[j]);
      j++;
    }
  }

  while (i < middle) {
    result.push_back(sequence[i]);
    i++;
  }

  while (j < right) {
    result.push_back(sequence[j]);
    j++;
  }

  for (i = left; i < right; i++) {
    sequence[i] = result[i - left];
  }
}

void split(std::vector<int> &sequence, int left, int right) {
  if (left + 1 == right) {
    return;
  }
  int middle = (left + right) / 2;
  split(sequence, left, middle);
  split(sequence, middle, right);
  mergeArrays(sequence, left, middle, right);
}

std::vector<int> mergeSort(std::vector<int> sequence) {

  split(sequence, 0, sequence.size());

  return sequence;
}


------------------------------------

string addDigits(long a, long b, int n) {
	    int k = 0;
            while (true)
            {
                for (long i = 9; i >= 0; i--)
                {
                    if ((a * 10 + i) % b == 0)
                    {
                        if (k == n) { return a.ToString(); }
                        a = a * 10 + i;
                        k++;
                        break;
                    }
                }
                if (a % b != 0) break;
            }

            return a.ToString();
}



int sumprimeFactors(int n)
        {
            //List<int> p = new List<int>();
            int p = 0;
            // Print the number of 2s that divide n 
            while (n % 2 == 0)
            {
                //Console.Write(2 + " ");
                //p.Add(2);
                p += 2;
                n /= 2;
            }

            // n must be odd at this point. So we can 
            // skip one element (Note i = i +2) 
            for (int i = 3; i <= Math.Sqrt(n); i += 2)
            {
                // While i divides n, print i and divide n 
                while (n % i == 0)
                {
                    //Console.Write(i + " ");
                    //p.Add(i);
                    p += i;
                    n /= i;
                }
            }

            // This condition is to handle the case whien 
            // n is a prime number greater than 2 
            if (n > 2)
            {
                //p.Add(n);
                p += n;
            }
            //Console.Write(n);

            return p;
        }

         int factorSum(int n)
        {
            
            HashSet<int> hash = new HashSet<int>();
            
            while (true)
            {
                n = sumprimeFactors(n);
                
                if (!hash.Add(n)) break ;
               
            }
            return n;
        }



----------------------------------

string longestDigitsPrefix(string inputString) {
string pre = "";
            for (int i = 0; i < inputString.Length; i++)
            {
                if (inputString[i] >= '0' && inputString[i] <= '9')
                {
                    pre += inputString[i];
                }
                else
                {
                    break;
                }

            }
            return pre;
}


std::vector<int> eratosthenesSieve(int n) {

  std::vector<int> primes;
  std::vector<bool> mayBePrime(n + 1, true);

  for (int i = 2; i <= n; i++) {
    if (mayBePrime[i]) {
      primes.push_back(i);
      for (int j = i; i * j <= n; j++) {
        mayBePrime[i * j] = false;
      }
    }
  }

  std::vector<int> result;
  for (int i = 0; i < primes.size(); i++) {
    result.push_back(primes[i]);
  }

  return result;
}

bool higherVersion(string ver1, string ver2) {
    string[] s1 = ver1.Split('.');
    string[] s2 = ver2.Split('.');
    for(int i=0;i<Math.Min(s1.Length,s2.Length);i++) {
        if(int.Parse(s1[i])>int.Parse(s2[i]))
            return true;
        else if(int.Parse(s1[i])<int.Parse(s2[i]))
            return false;
    }
    return false;
}

int niceFractions2(int n) {
  int res = 0;
  for (int i = 0; i*n < int(1e5); i++) {
    bool digits[10] = {};
    int a = i * n;
    int b = i;
    bool isNice = true;
    for (int j = 0; j < 5; j++) {
      digits[a % 10] = true;
      a /= 10;
      digits[b % 10] = true;
      b /= 10;
    }
    for (int j = 0; j < 10; j++) {
      if (!digits[j]) {
        isNice = false;
        break;
      }
    }
    if (isNice) {
      res++;
    }
  }
  return res;
}


int combs(string comb1, string comb2) {
	    string c1 = comb1;
            string c2 = comb2;

            if (c2.Length <= c1.Length)
            {
                c1 = comb2;
                c2 = comb1;
            }
            int izq = 0, der = comb1.Length + comb2.Length;

            int minLen = comb1.Length + comb2.Length;

            while (der >= 0)
            {
                string cerosIzqC1 = new string('0', comb2.Length);
                string cerosDerC1 = new string('0', comb2.Length);
                c1 = cerosIzqC1 + comb1 + cerosDerC1;

                string cerosIzq = new string('0', izq);
                string cerosDer = new string('0', der);

                c2 = cerosIzq + comb2 + cerosDer;
                Console.WriteLine(c1);
                Console.WriteLine(c2);
                Console.WriteLine();

                bool encajanTodos = true;

                for (int i = 0; i < c1.Length; i++)
                {
                    if (c1[i] != '0' && c2[i] != '0')
                    {
                        if (c1[i] == '*' && c2[i] == '*')
                        {
                            encajanTodos = false;
                            break;
                        }
                    }
                }

                if (encajanTodos)
                {
                    //int primerAsteriscoC2 = c2.IndexOf('*');
                    //int ultimoAsteriscoC1 = c1.LastIndexOf('*');

                    int primerC1 = c1.IndexOf('*');
                    int primerC2 = c2.IndexOf('*');

                    int ultimoC1 = c1.LastIndexOf('*');
                    int ultimoC2 = c2.LastIndexOf('*');

                    minLen = Math.Min(minLen, Math.Max(ultimoC1, ultimoC2)- Math.Min(primerC1, primerC2)+1);


                }

                Console.WriteLine("Min len: " + minLen);

                der--;
                izq++;
            }

            return minLen;
}



int dfsComponentSize(boolean[][] matrix, int vertex) {
class Helper {
            int componentSize = 0;

            void dfs(int currentVertex, ArrayList<Boolean> visited) {
                visited.set(currentVertex, true);
                componentSize++;
                for (int nextVertex = 0; nextVertex < matrix.length; nextVertex++) {
                    if (matrix[currentVertex][nextVertex] && !visited.get(nextVertex)) {
                        dfs(nextVertex, visited);
                    }
                }
            }
        }
        Helper h = new Helper();

        ArrayList<Boolean> visited = new ArrayList<>();

        for (int i = 0; i < matrix.length; i++) {
            visited.add(false);
        }

        h.dfs(vertex, visited);

        return h.componentSize;
}


bool validTime(std::string Time) {

  struct Helper {
    int charToInt(char symbol) {
      return int(symbol) - int('0');
    }
  };

  Helper h;

  int hours = h.charToInt(Time[0]) * 10 + h.charToInt(Time[1]),
      minutes = h.charToInt(Time[3]) * 10 + h.charToInt(Time[4]);

  if (hours < 24 && minutes < 60) {
    return true;
  }
  return false;
}


int arrayMinimumIndex(int[] inputArray) {
int ind = -1, min = int.MaxValue;
            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i] < min)
                {
                    min = inputArray[i];
                    ind = i;
                }
            }
            return ind;
}

bool isEarlier(int[] time1, int[] time2) {
  return  time1[0] < time2[0] || (time1[0] == time2[0]&& time1[1]<time2[1] )  ;
}

bool isEarlier(std::vector<int> time1, std::vector<int> time2) {
  if (time1[0] < time2[0] || (time1[0] == time2[0]&& time1[1]<time2[1] )) {
    return true;
  }
  return false;
}

bool charactersRearrangement(string string1, string string2) {
  char[] ch1 = string1.ToCharArray();
            Array.Sort(ch1);

            char[] ch2 = string2.ToCharArray();
            Array.Sort(ch2);

            return new string(ch1) == new string(ch2);
}



function seatsInTheater(nCols, nRows, col, row) {
  return (nCols-col+1) * (nRows-row)
}

int arrayMinimumAboveBound(int[] inputArray, int bound) {
	    int dif = int.MaxValue;
            int min_dif = int.MaxValue;
            int ans = -51;
            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i] > bound)
                {
                    dif = inputArray[i] - bound;
                    if (dif < min_dif)
                    {
                        min_dif = dif;
                        ans = inputArray[i];
                    }
                }
            }
            return ans;
}


bool checkFactorial(int n) {
    int prod = 1;
            for (int i = 1; ; i++)
            {
                prod *= i;
                if (prod == n) return true;
                if (prod > n) break;
            }
            return false;
}

int[] extractMatrixColumn(int[][] matrix, int column) {
 List<int> ans = new List<int>();
            for (int i = 0; i < matrix.Length; i++)
            {
                ans.Add(matrix[i][column]);
            }
            return ans.ToArray();
}

string strangeCode(int s, int e) {
 	    string res = "";
            char last = 'b';
            while (s < e - 1)
            {
                s++;
                e--;
                if (last == 'a')
                {
                    res += 'b';
                    last = 'b';
                }
                else
                {
                    res += 'a';
                    last = 'a';
                }
            }
            return res;
}


int[] directionOfReading(int[] numbers) {
 int max_len = numbers.Length;
            //for (int i = 0; i < numbers.Length; i++)
            //{
            //    max_len = Math.Max(max_len, numbers[i].ToString().Length);
            //}

            List<string> lista = new List<string>();
            for (int i = 0; i < numbers.Length; i++)
            {
                lista.Add(new string('0', max_len - numbers[i].ToString().Length) + numbers[i].ToString()); 
            }

            //foreach (string item in lista)
            //{
            //    Console.WriteLine(item);
            //}
            //return new int[0];

            List<int> ans = new List<int>();
            for (int j = 0; j < lista[0].Length; j++)
            {
                string item = "";
                for (int i = 0; i < lista.Count; i++)
                {
                    item += lista[i][j] + "";
                }
                ans.Add(int.Parse(item));
            }

            return ans.ToArray();
}



boolean pairOfShoes(int[][] shoes) {
  ArrayList<Integer> leftShoes = new ArrayList<>();
  ArrayList<Integer> rightShoes = new ArrayList<>();
  for (int i = 0; i < shoes.length; i++) {
    if (shoes[i][0] == 0) {
      leftShoes.add(shoes[i][1]);
    } else {
      rightShoes.add(shoes[i][1]);
    }
  }
  Collections.sort(leftShoes);
  Collections.sort(rightShoes);
  if (leftShoes.size() != rightShoes.size()) {
    return false;
  }
  for (int i = 0; i < leftShoes.size(); i++) {
    if (leftShoes.get(i)  != rightShoes.get(i)) {
      return false;
    }
  }
  return true;
}



int permutationShift(int[] permutation) {
int[] ans = new int[permutation.Length];
            int k =0;
            for (int i = 0; i < permutation.Length; i++)
            {
                ans[k++] = permutation[i] - i;
            }
            return ans.Max() - ans.Min();
}


 int halvingSum(int n)
        {
            int sum = 0;
            while (n >= 1)
            {
                sum += n;
                n /= 2;
            }
            return sum;
        }


int arrayMode(int[] sequence) {
  Dictionary<int, int> dic = new Dictionary<int, int>();
            int moda = -1;
            int max_frec = 0;
            foreach (int item in sequence)
            {
                if (dic.ContainsKey(item))
                {
                    dic[item]++;
                }
                else
                {
                    dic[item] = 1;
                }
                if (dic[item] > max_frec)
                {
                    max_frec = dic[item];
                    moda = item;
                }

            }
            return moda;
}


int[] alternatingSums(int[] a) {
 int x = 0, y = 0;
            for (int i = 0; i < a.Length; i++)
            {
                if (i % 2 == 0)
                {
                    x += a[i];
                }
                else
                {
                    y += a[i];
                }
            }
            return new int[] { x, y };
}

int summaryProficiency(int[] a, int n, int m) {
 
            int sum = 0;
            int cont = 0;
            for (int i = 0; i < a.Length  ; i++)
            {
                if (a[i] >= m)
                {
                    sum += a[i];
                    cont++;
                    if (cont == n) break;
                }
            }
            return sum;
}


int adjacentElementsProduct(int[] inputArray) {
int ans = int.MinValue;
            for (int i = 0; i + 1 < inputArray.Length; i++)
            {
                ans = Math.Max(ans, inputArray[i] * inputArray[i + 1]);
            }
            return ans;
}

 string longestString(string[] inputArray)
        {
            string lon = inputArray[0];
            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i].Length > lon.Length)
                {
                    lon = inputArray[i];
                }
            }
            return lon;
        }

int zigzag(int[] a) {

  int best = 1;
  int left = 0;
  while (left < a.length) {
    int right = left + 1;
    while (right < a.length) {
      if (right == left + 1) {
        if (a[left] == a[right]) {
          break;
        }
      } else {
        if ((a[right - 1] - a[right - 2]) * (a[right - 1] - a[right]) <= 0) {
          break;
        }
      }
      right++;
    }
    best = Math.max(best, right - left);
    left = right;
    if (left < a.length && a[left - 1] != a[left]) {
      left--;
    }
  }

  return best;
}



int sumOfPowers(int n, int divisor) {
	int sum = 0;
            for (int i = 1; i <= n; i++)
            {

                for (int p = n; p >= 0; p--)
                {
                    if (i % (int) Math.Pow(divisor, p) == 0)
                    {
                        sum += p;
                        break;
                    }

                }

            }

            return sum;
}


int differentValues(int[] a, int d) {

  int best = -1;
  for (int i = 0; i < a.length; i++) {
    for (int j = i + 1; j < a.length; j++) {
      int diff = Math.abs(a[j] - a[i]);
      if (diff > d && (diff < best || best == -1)) {
        best = diff;
      }
    }
  }

  return best;
}


int minimalMultiple(int divisor, int lowerBound) {
	return (int)Math.Ceiling( (double) lowerBound / (double) divisor) * divisor;
}

boolean reachNextLevel(int experience, int threshold, int reward) {
    
    return experience+reward >= threshold;

}


bool rightTriangle(int[] sides) {
    Array.Sort(sides);

            return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2];
}



int sequenceElement(std::vector<int> a, int n) {

  const int MOD = (int)1e5;
  std::vector<int> seq;
  for (int i = 0; i < 5; i++) {
    seq.push_back(a[i]);
  }

  int lastFive = a[0] * (int)1e4 + a[1] * (int)1e3 +
                 +a[2] * (int)1e2 + a[3] * (int)1e1 +
                  a[4] * (int ) 1e0;
  std::map<int, int> was;
  was[lastFive] = 4;

  for (int i = 5;; i++) {
    seq.push_back((seq[i - 1] + seq[i - 2] +
              seq[i - 3] + seq[i - 4] + seq[i - 5]) % 10);
    lastFive = (lastFive * 10 + seq[i]) % MOD;
    if (was.find(lastFive) != was.end()) {
      int last = was[lastFive];
      return seq[n % (i - last)];
    } else {
      was[lastFive] = i;
    }
  }
}

string[] binaryGenerator(string s) {
	   HashSet<string> a = new HashSet<string>();
            a.Add("");

            foreach(char ch in s)
            {
                HashSet<string> b = new HashSet<string>();
                foreach(string  c in a)
                {
                    b.Add(c + "1");
                    if (ch == '0') b.Add(c + "0");
                }
                a = b;
            }
            List<string> r = a.ToList();
            r.Sort();
            return r.ToArray();
}

int countIncreasingSequences(int n, int k) {

  /*
   * vector dp (short for dynamic programming)
   * is used for storing the interim values.
   */
  std::vector<int> line(k + 1, 0);
  std::vector<std::vector<int>> dp(n + 1, line);
  dp[0][0] = 1;

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= k; j++) {
      for (int q = 0; q < j; q++) {
        dp[i][j] += dp[i - 1][q];
      }
    }
  }

  int sum = 0;
  for (int j = 1; j <= k; j++) {
    sum += dp[n][j];
  }

  return sum;
}



bool isPrime(int n) {
	   if (n < 2) return false;
            if (n == 2) return true;
            if (n % 2 == 0) return false;

            for (int i = 3; i * i <= n; i += 2)
            {
                if (n % i == 0) return false;
            }
            return true;
}

int differentSubstringsTrie(std::string inputString) {

  typedef std::vector<std::vector<int>> Array2D;

  struct Helper {
    Array2D addNode(Array2D lastVersion) {
      std::vector<int> line(26, 0);
      lastVersion.push_back(line);
      return lastVersion;
    }
  };

  Helper h;

  int nodesCount = 1;
  Array2D trie;
  trie = h.addNode(trie);

  for (int i = 0; i < inputString.size(); i++) {
    int currentNode = 0;
    for (int j = i; j < inputString.size(); j++) {
      int symbol = inputString[j] - 'a';
      if (!trie[currentNode][symbol]) {
        trie = h.addNode(trie);
        trie[currentNode][symbol] = nodesCount;
        nodesCount++;
      }
      currentNode = trie[currentNode][symbol];
    }
  }

  return nodesCount - 1;
}

int differentSubstringsTrie(string s) {
           HashSet<string> hash = new HashSet<string>();

            for (int i = 0; i < s.Length; i++)
            {
                for (int j = i; j < s.Length; j++)
                {
                    hash.Add(s.Substring(i, j - i + 1));
                }
            }

            return hash.Count;
}



boolean isTournament(int n, int[] fromV, int[] toV) {

  ArrayList<ArrayList<Boolean>> edges = new ArrayList<>();

  for (int i = 0; i < n; i++) {
    ArrayList<Boolean> line = new ArrayList<>();
    for (int j = 0; j < n; j++) {
      line.add(false);
    }
    edges.add(line);
  }

  for (int i = 0; i < fromV.length; i++) {
    edges.get( fromV[i] - 1 ).set( toV[i] - 1, true );
  }

  for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
      if (edges.get(i).get(j) == edges.get(j).get(i)) {
        return false;
      }
    }
  }

  if (fromV.length != n * (n - 1) / 2) {
    return false;
  }
  return true;
}



int factorialsProductTrailingZeros(int l, int r) {
 int result = 0,
                last = 0;
            for (int i = 1; i <= r; i++)
            {
                int number = i;
                while (number % 5 == 0)
                {
                    number /= 5;
                    last++;
                }
                if (i >= l)
                {
                    result += last;
                }
            }
            return result;
}

function bfsComponentSize(matrix) {

  var visited = [];
  var queue = [];
  var componentSize = 0;

  for (var i = 0; i < matrix.length; i++) {
    visited.push(false);
  }

  visited[1] = true;
  queue.push(1);
  while (queue.length) {
    var currentVertex = queue.shift();
    visited[currentVertex] = true;
    componentSize++;
    for (var nextVertex = 0; nextVertex < matrix.length; nextVertex++) {
      if (matrix[currentVertex][nextVertex] && !visited[nextVertex]) {
        visited[nextVertex] = true;
        queue.push(nextVertex);
      }
    }
  }

  return componentSize;
}



int digitSum(int n) {
int sum = 0;
            while (n > 0)
            {
                sum += n % 10;
                n /= 10;
            }
            return sum;
}



 bool findPath(int[][] matrix)
        {
            int f = 0, c = 0;

            for (int i = 0; i < matrix.Length; i++)
            {
                for (int j = 0; j < matrix[i].Length; j++)
                {
                    if (matrix[i][j] == 1)
                    {
                        f = i;
                        c = j;
                        goto e;
                    }
                }
            }

        e:
            //Console.WriteLine("hola");
            //int i = 
            int v =1;

            //int max = matrix.Length * matrix[0].Length;
            int n = matrix.Length;
            int m = matrix[0].Length;

            bool[][] marcas = new bool[n][];
            for (int i = 0; i < n; i++)
            {
                marcas[i] = new bool[m];
                for (int j = 0; j < m; j++)
                {
                    marcas[i][j] = false;
                }
            }

            marcas[f][c] = true;

            while (true)
            {
                if (f - 1 >= 0 && matrix[f - 1][c] == v + 1)
                {
                    marcas[f - 1][c] = true;
                    f--;
                    v++;
                }
                else if (f + 1 < matrix.Length && matrix[f + 1][c] == v + 1)
                {
                    marcas[f + 1][c] = true;
                    f++;
                    v++;

                }
                else if (c - 1 >= 0 && matrix[f][c - 1] == v + 1)
                {
                    marcas[f][c - 1] = true;
                    c--;
                    v++;
                }
                else if (c + 1 < matrix[0].Length && matrix[f][c + 1] == v + 1)
                {
                    marcas[f][c + 1] = true;
                    c++;
                    v++;
                }
                else
                {
                    break;
                }
            }

            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < m; j++)
                {
                    if (!marcas[i][j])
                    {
                        return false;
                    }
                }
            }
            return true;
        }

--------------------------------------------

 static int[] Sum(int[] a)
        {
            //int sum = 0;
            List<int> lista = new List<int>();
            for(int i =0; i + 1<a.Length; i+=2)
            {
                //sum += a[i] + a[i + 1];
                lista.Add(a[i] + a[i + 1]);
            }
            return lista.ToArray();
        }

        static int[] Prod(int[] a)
        {
            //int prod = 1;
            List<int> lista = new List<int>();
            for(int i =0; i+1 < a.Length; i+=2)
            {
                //prod += a[i] * a[i + 1];
                lista.Add(a[i] * a[i + 1]);
            }
            return lista.ToArray();
        }
        static int arrayConversion(int[] inputArray)
        {

            if (inputArray.Length == 1) return inputArray.First();
            while (true)
            {
                 inputArray = Sum(inputArray);
                if (inputArray.Length == 1) return inputArray.First();
                inputArray = Prod(inputArray);
                if (inputArray.Length == 1) return inputArray.First();
            }
        }
-----------------------------------------



typedef std::vector<std::vector<char>> Canvas;

Canvas drawRectangle(Canvas canvas, std::vector<int> rectangle) {
  for (int i = rectangle[0] + 1; i < rectangle[2]; i++) {
    canvas[rectangle[1]][i] = '-';
    canvas[rectangle[3]][i] = '-';
  }
  for (int i = rectangle[1] + 1; i < rectangle[3]; i++) {
    canvas[i][rectangle[0]] = '|';
    canvas[i][rectangle[2]] = '|';
  }
  for (int i = 0; i < 4; i += 2) {
    for (int j = 1; j < 4; j+=2) {
      canvas[rectangle[j]][rectangle[i]] = '*';
    }
  }
  return canvas;
}





 static int chessKnightMoves(string cell)
        {
            int letra = (int)cell[0] - (int)'a' + 1;
            int num = (cell[1] - '0');

            // Console.WriteLine(letra + " " + num);

            int ans = 0;
            if (letra - 2 >= 1)
            {
                if (num + 1 <= 8)
                {
                    ans++;
                }
                 if (num - 1 >= 1)
                {
                    ans++;
                }
            }
            if (letra + 2 <=8)
            {
                if (num + 1 <= 8)
                {
                    ans++;
                }
                 if (num - 1 >= 1)
                {
                    ans++;
                }
            }


            if (num + 2 <= 8)
            {
                if (letra + 1 <= 8)
                {
                    ans++;
                }
                if (letra - 1 >= 1)
                {
                    ans++;
                }
            }

            if (num - 2 >=1 )
            {
                if (letra + 1 <= 8)
                {
                    ans++;
                }
                if (letra - 1 >= 1)
                {
                    ans++;
                }
            }



            return ans;
        }




static int maxSubmatrixSum(int[][] matrix, int n, int m)
        {

            int max_sum = int.MinValue;
            for (int i = 0; i < matrix.Length - n +1 ; i++)
            {
                for (int j = 0; j < matrix[i].Length - m+1 ; j++)
                {
                    int sum = 0;
                    for (int k = i; k < i + n ; k++)
                    {
                        for (int l = j; l < j + m ; l++)
                        {
                            sum += matrix[k][l];
                        }
                    }
                    max_sum = Math.Max(max_sum, sum);
                }

            }
            return max_sum;

        }

int sumBelowBound(int bound) {
 int sum = 0;
            
            
            for( int i = 1 ;  ;i++)
            {
                if(sum + i <= bound)
                {
                    sum += i;
                }
                else
                {
                    return i-1;
                }
            }

            return -1;
}


bool isSum(int value) {
	//sacado de -b+-sqrt(b^2 - 4ac)/2a
   return ((-1.0 + Math.Sqrt(1.0 + 8 * value)) / 2.0) % 1 ==0;
}


bool isSum(int value) {
	    for (int n = 1; n <= value; n++)
            {
                if ((n * (n + 1)) / 2 == value)
                {
                    return true;
                }
                if ((n * (n + 1)) / 2 > value) break;
            }
            return false;
}


bool leapYear(int year) {
  return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);

}


int fixedPointsPermutation(int[] permutation) {
int ans = 0;
            for(int i =0; i<permutation.Length; i++)
            {
                if(i+1 == permutation[i])
                {
                    ans++;
                }
            }
            return ans;
}


int centuryFromYear(int year) {
	    int century = 1;
            for(int i =1; ; i+=100)
            {
                if(year >= i && year <= i+99)
                {
                    return century;
                }
                century++;
            }
}


int pagesNumbering(int n) {
	    int cont = 0;
            for (int i=1; i<=n; i++)
            {
                //cont += i.ToString().Length;
                int copia = i;
                while(copia > 0)
                {
                    cont++;
                    copia /= 10;
                }
            }
            return cont;
}


private static boolean reverseToSort(ArrayList<Integer> inputArray) {

        for (int i = 0; i < inputArray.size(); i++) {
            for (int j = i + 1; j <= inputArray.size(); j++) {
                ArrayList<Integer> middle = new ArrayList<>(),
                        result = new ArrayList<>();
                result.addAll(inputArray.subList(0, i));
                middle.addAll(inputArray.subList(i, j));
                Collections.reverse(middle);
                result.addAll(middle);
                result.addAll(inputArray.subList(j, inputArray.size()));

                boolean correct = true;

                for (int k = 1; k < result.size(); k++) {
                    if (result.get(k - 1) >= result.get(k)) {
                        correct = false;
                        break;
                    }
                }
                if (correct) {
                    return true;
                }
            }
        }
        return false;
    }


String caesarBoxCipherEncoding(String s) {

        int c = (int) Math.sqrt(s.length());

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < c; i++) {
            int j = i;
            while (j < s.length()) {

                sb.append(s.charAt(j));
                j+=c;
            }
        }

        return sb.toString();
    }


int arrayKthGreatestQuick(std::vector<int> inputArray, int k) {

  int pos = int(double(rand()) / RAND_MAX * inputArray.size());
  std::vector<int> left, right;

  if (inputArray.size() == 1) {
    return inputArray[0];
  }

  for (int i = 0; i < inputArray.size(); i++) {
    if(inputArray[i] < inputArray[pos]) left.emplace_back(inputArray[i]);
    else right.emplace_back(inputArray[i]);
  }

  if (right.size() >= k) {
    return arrayKthGreatestQuick(right, k);
  }
  return arrayKthGreatestQuick(left, k - right.size());
}



int toAndFro(int a, int b, int t) {
int len =  Math.abs(a-b);
  t %= (2 * len);
  if (t <= len) {
    return a + (b - a) / Math.abs(b - a) * t;
  }
  else {
    t -= len;
    return b + (a - b) / Math.abs(a - b) * t;
  }
}


int countSumOfTwoRepresentations(int n, int l, int r) {
    var count = 0;
    for (var a = l; a <= r; a++)
        if (a <= n - a && n - a >= l && n - a <= r)
            count++;

    return count;
}


int smallestMultiple(int left, int right) {
            for(int i =1; ;i++)
            {
                bool flag = true;
                for(int j =left; j<= right; j++)
                {
                    if (i % j != 0)
                    {
                        flag = false;
                    }
                }
                if (flag) return i;
            }
}



int equidistantTriples(int[] coordinates) {

  int ans = 0;
  for (int i = 1; i < coordinates.length - 1; i++) {
    int left = i - 1;
    int right = i + 1;
    while (left >= 0 && right < coordinates.length) {
      int distL =  coordinates[i] -coordinates[left]  ;
      int distR = coordinates[right] - coordinates[i];
      if (distL == distR) {
        ans++;
        left--;
        right++;
      } else if (distL < distR) {
        left--;
      } else {
        right++;
      }
    }
  }

  return ans;
}


int maxSubarray(int[] a) {
int max_so_far = 0; 
   int curr_max = 0; 
  
   for (int i = 0; i < a.Length; i++) 
   { 
        curr_max = Math.Max(a[i], curr_max+a[i]); 
        max_so_far = Math.Max(max_so_far, curr_max); 
   } 
   return max_so_far; 
}


int houseNumbersSum(int[] inputArray) {
     int sum = 0;
            for(int i =0; i < inputArray.Length && inputArray[i] != 0; i++)
            {
                sum += inputArray[i];
            }
            return sum;
}


bool isIdentityMatrix(std::vector<std::vector<int> > matrix) {
	
	for(int i =0; i<matrix.size(); i++) {
		
		for(int j =0; j<matrix[i].size(); j++ ) {
			if(i == j) {
				if(matrix[i][j] != 1) {
					return false;
				}
			}
			else{
				if(matrix[i][j] !=0) return false;
			}
		}
		
	}
	
	return true;
	
}

int stringsConstruction(std::string a, std::string b) {
        map<char, int> hash_a;
	map<char, int> hash_b;
	
	for(int i =0; i<a.size(); i++) {
		hash_a[a[i]]++;
	}
	
	for(int i =0; i<b.size(); i++) {
		hash_b[b[i]]++;
	}
	
	int m = INT_MAX;
	for(int i =0; i<a.size(); i++) {
		m =  min(m,  hash_b[a[i]] / hash_a[a[i]]);
	}
	
	return m;
}

def binaryPower(n, k):
    MOD = 10 ** 7 + 7

    if k == 0:
        return 1
    if k % 2 == 0:
        return (binaryPower(n, k // 2)**2) % MOD
    return (binaryPower(n, k - 1) * n) % MOD



string buildPalindrome(string st) {
int i = 0;
            for (  ; i < st.Length; i++)
            {
                string subs = st.Substring(i, st.Length - i );
                char[] ch = subs.ToCharArray();
                Array.Reverse(ch);
                if (subs == new string(ch))
                {
                    break;
                }
            }

            string pre = st.Substring(0, i);
            char[] rev_pre = pre.ToCharArray();
            Array.Reverse(rev_pre);
            return st + new string(rev_pre);
}


bool equationTemplate(int[] values) {
	    Array.Sort(values);

            int a = values[0];
            int b = values[1];
            int c = values[2];
            int d = values[3];

            return a * b * c == d ||
                   a * b == c * d ||
                   a * c == b * d ||
                   a * d == b * c ||
                   a * b * d == c ||
                   a * c * d == b || 
                   b * c * d == a;
}


int nearestSmallerEqFib(int n) {
       
        if (n == 0 || n == 1)
            return n;

       
        int f1 = 0, f2 = 1, f3 = 1;
        while (f3 <= n) {
            f1 = f2;
            f2 = f3;
            f3 = f1 + f2;
        }
        return f2;
    }

      int[] fibonacciSum(int n) {
        ArrayList<Integer> fibSumArr = new ArrayList<>();
        while (n > 0) {
           
            int f = nearestSmallerEqFib(n);

            
            fibSumArr.add(f);

           
            n = n - f;
        }
        Collections.reverse(fibSumArr);
        return fibSumArr.stream().mapToInt(i -> i).toArray();
    }


int kthDivisor(int n, int k) {
int cont = 0;
            for (int i = 1; i <= n; i++)
            {
                if (n % i == 0)
                {
                    cont++;
                }
                if (cont == k) return i;
            }
            return -1;
}


def variableName(name):
    if name[0].isdigit():
        return False
    for e in name:

        if (e >='A' and e <= 'Z') or (e >='a' and e <= 'z') or e == '_' or (e >='0' and e <= '9'):
            pass
        else:
            return False
    return True


int[] powersOfTwo(int n) {
        ArrayList<Integer> ans = new ArrayList<>();
        int cur = 1;
        while (n > 0) {
            if ((n & 1) != 0) {
                ans.add(cur);
            }
            n >>= 1;
            cur <<= 1;
        }

        int[] a = new int[ans.size()];
        for (int i = 0; i < a.length; i++) {
            a[i] = ans.get(i);
        }

        return a;
}



int arraySumAdjacentDifference(int[] inputArray) {
	    int sum = 0;
            for (int i = 0; i + 1 < inputArray.Length; i++)
            {
                sum += Math.Abs(inputArray[i] - inputArray[i + 1]);
            }
            return sum;
}


int[] robotPath(string instructions, int bound) {
            int[] dx = { -1, 0, 1, 0 };
            int[] dy = { 0, 1, 0, -1 };
            int x = 0, y = 0;
            string dirs = "LURD";

            for (int i = 0; i < instructions.Length; i++)
            {
                int j = dirs.IndexOf(instructions[ i]);
                if (Math.Abs(x + dx[j]) <= bound &&
                    Math.Abs(y + dy[j]) <= bound)
                {
                    x += dx[j];
                    y += dy[j];
                }
            }

            return new int[] { x, y };
}



string reduceString(string inputString) {
int i = 0, j = inputString.Length - 1;

            while (i < j)
            {
                if (inputString[i] == inputString[j])
                {
                    i++;
                    j--;
                }
                else
                {
                    break;
                }
            }

            string ans = inputString.Substring(i,j-i+1);
            if (ans.Length == 1) return "";
            return ans;
}

int oddNumbersBeforeZero(int[] sequence) {
int odds = 0;
            
            for (int i = 0; i < sequence.Length; i++)
            {
                if (sequence[i] == 0) break;
                if (sequence[i] % 2 != 0) odds++;
            }
            return odds;
}


int countSumOfTwoRepresentations2(int n, int l, int r) {
   int result = 0;

    for (int a = l; a <= r; a++) {
        int b = n - a;
        if (b >= l && b <= r && b >= a) {
            result++;
        }
    }
    return result;
}


int equalPairOfBits(int n, int m) {
	return n + m + 1 & ~m - n ;
}



string lineEncoding(string s) {
     int cont = 1;
            char actual = s[0];
            string ans = "";
            for (int i = 1; i < s.Length; i++)
            {
                if (actual == s[i])
                {
                    cont++;
                }
                else
                {
                    if (cont > 1)
                    {
                        ans += cont + "" + actual;
                    }
                    else
                    {
                        ans += actual;
                    }
                    cont = 1;
                }
                actual = s[i];
            }
            if (cont > 1)
            {
                ans += cont + "" + actual;
            }
            else
            {
                ans += actual;
            }

            return ans;
}





bool symbolsPermutation(string word1, string word2) {
char[] ch1 = word1.ToCharArray();
            Array.Sort(ch1);
            char[] ch2 = word2.ToCharArray();
            Array.Sort(ch2);
            return new string(ch1) == new string(ch2);
}

bool checkEqualFrequency(int[] inputArray) {
  Dictionary<int, int> dic = new Dictionary<int, int>();
            for (int i = 0; i < inputArray.Length; i++)
            {
                if (dic.ContainsKey(inputArray[i]))
                {
                    dic[inputArray[i]]++;
                }
                else
                {
                    dic[inputArray[i]] = 1;
                }

            }

            return dic.Values.ToArray().Distinct().ToArray().Length == 1;
}



int differentSquares(int[][] matrix) {
            HashSet<string> hash = new HashSet<string>();
            for (int i = 0; i +1 < matrix.Length; i++)
            {
                for (int j = 0; j  + 1< matrix[i].Length; j++)
                {
                    hash.Add(matrix[i][j] + " " + matrix[i][j + 1] + " "
                        + matrix[i + 1][j] + " " + matrix[i + 1][j + 1]);

                }
            }
            return hash.Count;
}


bool willYou(bool young, bool beautiful, bool loved) {
     bool c1 = (young && beautiful) && !loved;
            bool c2 = loved && (!young || !beautiful);

            return c1 || c2;
}



bool increaseNumberRoundness(int n) {
    while (n % 10 == 0)
            {
                n /= 10;
            }

            string s = n.ToString();

            for (int i = 0; i < s.Length; i++)
            {
                if (s[i] == '0')
                {
                    return true;
                }
            }
            return false;
}


int differentValues(std::vector<int> a, int d) {

  int best = -1;
  for (int i = 0; i < a.size(); i++) {
    for (int j = i + 1; j < a.size(); j++) {
      int diff = abs(a[j] - a[i]);
      if (diff <= d && best < diff) {
        best = diff;
      }
    }
  }

  return best;
}


int[] primeFactors(int n) {
          List<int> hash = new List<int>();
            while (n % 2 == 0)
            {
                //Console.Write(2 + " ");
                hash.Add(2);
                n /= 2;
            }


            for (int i = 3; i * i <= n; i += 2)
            {

                while (n % i == 0)
                {

                    hash.Add(i);
                    n /= i;
                }
            }


            if (n > 2)
            {

                hash.Add(n);
            }
            return hash.ToArray();
}




int matrixElementsSum(int[][] matrix) {
	int sum =0;
        for(int i =0; i<matrix[0].length;i++) {
            for(int j=0; j<matrix.length;j++) {
                if(matrix[j][i] > 0)
                    sum +=matrix[j][i];
                else
                    break;
            }
        }
        return sum;
}



bool isInsideTheCircle(int xa, int ya, int xc, int yc, int rc) {
  int dist = (xa - xc) * (xa - xc) + (ya - yc) * (ya - yc);
  rc *= rc;
  if (dist < rc) {
    return true;
  }
  return false;
}


bool checkIncreasingSequence(int[] seq) {
     for (int i = 0; i + 1 < seq.Length; i++)
            {
                if (seq[i + 1] <= seq[i])
                {
                    return false;
                }
            }
            return true;
}


int matrixTrace(int[][] matrix) {
int sum = 0;
            for (int i = 0; i < matrix.Length; i++)
            {
                sum += matrix[i][i];
            }
            return sum;
}



int[][] meanGroups(int[][] a) {
 Dictionary<double, List <int> > dic = new Dictionary<double, List<int>>();
            //int[][] ans = new int[a.Length][];
            for (int i = 0; i < a.Length; i++)
            {
                double sum = 0.0;
                for (int j = 0; j < a[i].Length; j++)
                {
                    sum += a[i][j];
                }
                double prom = sum / a[i].Length;

                if (dic.ContainsKey(prom))
                {
                    dic[prom].Add(i);
                }
                else
                {
                    dic[prom] = new List<int>();
                    dic[prom].Add(i);
                }

            }

            int[][] res = new int[dic.Count ][];
            int k =0;
            foreach (KeyValuePair<double, List<int>> kvp in dic)
            {
                List<int> lista_values = kvp.Value;
                lista_values.Sort();
                int[] vals = lista_values.ToArray();
                res[k++] = vals.ToArray(); 
            }

            return res;
}



static int countTinyPairs(int[] a, int[] b, int k)
        {
            //HashSet<string> hash = new HashSet<string>();

            int ans = 0;
             
            for (int i = 0; i < a.Length; i++)
            {
                 int x = int.Parse(  a[i] + "" + b[a.Length - i-1] );
                 if (x < k)
                 {
                     ans++;
                 }
            }


            return ans;
        }


int maxFraction(int[] numerators, int[] denominators) {
	    double max = 0.0;
            int ans = -1;
            for (int i = 0; i < numerators.Length; i++)
            {
                double f = (double) numerators[i] / (double) denominators[i];
                if (f > max)
                {
                    max = f;
                    ans = i;
                }
            }
            return ans;
}


int champernowneDigit(int n) {
 string s = "";
            for (int i = 1; i <= n; i++)
            {
                s += i.ToString() ;
            }
            return int.Parse(s[n-1].ToString());
}



int equationSolutions(int l, int r) {
    HashSet<string> pares = new HashSet<string>();
            for (int a = l; a <= r; a++)
            {
                for (int b = l; b <= r; b++)
                {
                    int cubo = a * a * a;
                    int cuad = b * b;

                    if (cuad == cubo)
                    {
                        pares.Add(Math.Min(a, b) + " " + Math.Max(a, b));
                    }
                }
            }
            return pares.Count;
}


def fileNaming(names):
    def calculateHash(inputString):
        P = 307
        M = 1000003
        hashValue = 0
        for i in range(len(inputString)):
            hashValue = (hashValue * P + ord(inputString[i])) % M
        return hashValue

    hashMapSize = len(names) * 2
    ##
    #     Information about the string in the hash map
    #     is stored in the following way:
    #     [string itself,
    #      its hash,
    #      the smallest possible integer to use with this name]
    ##
    hashMap = []
    result = []

    def searchHM(position, hashValue):
        while (hashMap[position][0] != ''
          and hashMap[position][1] != hashValue):
            position = (position + 1) % hashMapSize
        return position

    for i in range(hashMapSize):
        hashMap.append(['', -1, 0])

    for i in range(len(names)):
        hashValue = calculateHash(names[i])
        startPos = searchHM(hashValue % hashMapSize, hashValue)
        if hashMap[startPos][0] == '':
            hashMap[startPos] = [names[i], hashValue, 1]
            result.append(names[i])
        else:
            newName = names[i] + '(' + str(hashMap[startPos][2]) + ')'
            newNameHash = calculateHash(newName)
            position = searchHM(newNameHash % hashMapSize, newNameHash)

            while hashMap[position][0] != '':
                hashMap[startPos][2] += 1
                newName = names[i] + '(' + str(hashMap[startPos][2]) + ')'
                newNameHash = calculateHash(newName)
                position = searchHM(newNameHash % hashMapSize, newNameHash)
            hashMap[position] = [newName, newNameHash, 1]
            result.append(newName)
            hashMap[startPos][2] += 1

    return result


string caseUnification(string s)
        {
            int lower = 0, upper = 0;

            for (int i = 0; i < s.Length; i++)
            {
                if (char.IsUpper(s[i]))
                {
                    upper++;
                }
                else
                {
                    lower++;
                }
            }

            return upper > lower ? s.ToUpper() : s.ToLower();

        }


String decipher(String cipher) {

  String result = "";
  for (int i = 0; i < cipher.length(); ) {
    int len;
    if (cipher.charAt(i) == '1') {
      len = 3;
    } else {
      len = 2;
    }
    int code = Integer.parseInt(cipher.substring(i, i+len));
    result += (char) code;
    i += len;
  }

  return result;
}


int countWaysToChangeDigit(int value) {
        int ans = 0;
        while (value > 0) {
            ans += 9 - value % 10;
            value /= 10;
        }
        return ans;
}


int avoidObstacles(int[] inputArray) {

            //Array.Sort(inputArray);---->no
            int max = inputArray.Max();

            for (int dist = 1; dist <= max ; dist++)
            {
                HashSet<int> hash = new HashSet<int>();
                for (int i = 0; i<= max ; i += dist)
                {
                    hash.Add(i);
                }
                int j = 0;
                for (; j < inputArray.Length; j++)
                {
                    if (hash.Contains(inputArray[j]))
                    {
                        break;
                    }
                }
                if (j >= inputArray.Length)
                {
                    return dist;
                }

            }
            return max +1;
}



int uniqueDigitProducts(int[] a) {
           HashSet<int> hash = new HashSet<int>();
            for (int i = 0; i < a.Length; i++)
            {
                int copia = a[i];
                int prod = 1;
                while (copia > 0)
                {
                    prod *= copia % 10;
                    copia /= 10;
                }
                hash.Add(prod);
            }
            return hash.Count;
}



std::vector<int> fractionSubtraction(std::vector<int> a, std::vector<int> b) {
    vector<int> fraction = { a[0] * b[1] - a[1] * b[0], a[1] * b[1] };

        int div = min(fraction[0], fraction[1]);
        while (div != 1) {
            if (fraction[0] % div == 0 && fraction[1] % div == 0) {
                fraction[0] /= div;
                fraction[1] /= div;
                div = min(fraction[0], fraction[1]);
            } else
                div--;
        }
        return fraction;
}


int maxMultiple(int divisor, int bound) {
    
            for (int n = bound; n >= 1; n-- )
            {
                if (n % divisor == 0) return n;
            }
            return -1;
}



 static int specialPolynomial(int x, int n)
        {
            double sum = 0;
            int k = 0;
            for (; ; k++)
            {
                if (sum + Math.Pow(x, k) > n)  break;
                sum += Math.Pow(x, k);
            }
            return k - 1;
        }

string findEmailDomain(string address) {
int indiceArroba = address.LastIndexOf('@');
            return address.Substring(indiceArroba + 1, address.Length - indiceArroba - 1);

}


int sumOfSquares(int n) {
            int sum = 0;
            for (int i = 1; i <= n; i++)
            {
                sum += i * i ;
            }
            return sum;
}



string lookAndSaySequenceNextElement(string element) {
     string s = "";
            char actual = element[0];
            int cont = 1;
            for (int i = 1; i < element.Length; i++)
            {
                if (actual == element[i])
                {
                    cont++;
                }
                else
                {
                    s += cont + "" + actual;
                    actual = element[i];
                    cont = 1;
                }
            }

            if (cont >= 1)
            {
                s += cont + "" + actual;
            }

            return s;
}



static string[] addBorder(string[] picture)
        {
            string[] ans = new string[picture.Length + 2];

            int k = 0;
            for (int i = 0; i < ans.Length; i++)
            {
                if (i == 0 || i == ans.Length -1 )
                {
                    ans[i] = new string('*', picture[0].Length + 2);
                }
                else
                {
                    string fila = "";
                    fila += '*';
                    fila += picture[k] + '*';
                    ans[i] = fila;
                    k++;
                }
            }
            return ans;
        }


def polishNotation(tokens):
    def isNumber(stringRepresentation):
        return (len(stringRepresentation) > 1 or
              '0' <= stringRepresentation[0] and
              stringRepresentation[0] <= '9')

    stack = []

    for i in range(len(tokens)):
        stack.append(tokens[i])
        while (len(stack) > 2 and isNumber(stack[-1])
          and isNumber(stack[-2])):
            leftOperand = int(stack[-2]) 
            rightOperand = int(stack[-1])
            result = 0
            if stack[-3] == '-':
                result = leftOperand - rightOperand
            if stack[-3] == '+':
                result = leftOperand + rightOperand
            if stack[-3] == '*':
                result = leftOperand * rightOperand
            stack = stack[:-3]
            stack.append(str(result))

    return int(stack[0])



int arrayMaxConsecutiveSum(int[] inputArray, int k) {
            int sum = 0;
            for (int i = 0; i < k; i++)
            {
                sum += inputArray[i];
            }
            int max = sum;

            for (int i = 0; i + k < inputArray.Length; i++)
            {
                sum += inputArray[i + k];
                sum -= inputArray[i];
                max = Math.Max(max, sum);
            }
            return max;
}




bool isCaseInsensitivePalindrome(string inputString) {
    inputString = inputString.ToLower();
            int i = 0, j = inputString.Length - 1;

            while (i < j)
            {
                if (inputString[i] != inputString[j]) return false;

                i++;
                j--;
            }
            return true;
}



 int gcd(int a, int b)
        {
            if (b == 0)
                return a;
            return gcd(b, a % b);

        } 
         int[] fractionReducing(int[] fraction)
        {
            int g = gcd(fraction[0], fraction[1]);
            fraction[0] /= g;
            fraction[1] /= g;
            return fraction;
        }


string compareIntegers(string a, string b) {
    if (a.Length < b.Length) return "less";
            if (a.Length > b.Length) return "greater";

            for (int i = 0; i < a.Length; i++)
            {
                if (a[i] - '0' > b[i] - '0')
                {
                    return "greater";
                }
                else if (a[i] - '0' < b[i] - '0')
                {
                    return "less";
                }
            }

            return "equal";
}


int[] makeArrayConsecutive(int[] sequence) {
    int min = sequence.Min(), max = sequence.Max();
            HashSet<int> hash = new HashSet<int>(sequence);

            List<int> ans = new List<int>();
            for (int i = min; i <= max; i++)
            {
                if (!hash.Contains(i))
                {
                    ans.Add(i);
                }
            }

            return ans.ToArray();
}



   static int maximalEven(int[] inputArray)
        {
            int max = 0;
            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i] % 2 == 0)
                {
                    if (inputArray[i] > max)
                    {
                        max = inputArray[i];
                    }
                }
            }
            return max;
        }



string longestWord(string text) {
         string w = "";
            string max_w = "";
            for (int i = 0; i < text.Length; i++)
            {
                if ((text[i] >= 'a' && text[i] <= 'z') ||
                    (text[i] >= 'A' && text[i] <= 'Z'))
                {
                    w += text[i];
                }
                else
                {
                    w = "";
                }
                if (w.Length > max_w.Length)
                {
                    max_w = w;
                }
            }
            return max_w; 
}

bool alphabetSubstring(string s) {
     for (int i = 0; i + 1 < s.Length; i++)
            {
                if (s[i] + 1 != s[i+1])
                {
                    return false;
                }
            }
            return true;
}



int graphEdges(bool[][] matrix) {
	int c = 0;

        for (int i = 0; i < matrix.Length; ++i)
            for (int j = 0; j < matrix[i].Length; ++j)
                if (matrix[i][j])
                    ++c;

        return c / 2;
}


bool evenDigitsOnly(int n) {

  if (n == 0) {
    return true;
  }
  if (n % 2 != 0) {
    return false;
  }
  return evenDigitsOnly(n / 10);
}



int leastCommonMultiple(int a, int b) {

  int gcd = 1;
  for (int divisor = 2; divisor <= std::min(a, b); divisor++) {
    if (a % divisor == 0 && b % divisor == 0) {
      gcd = divisor;
    }
  }

  return a * b / gcd;
}

        static int[] onlyEvenNumbers(int left, int right)
        {
            List<int> ans = new List<int>();
            for (int i = left; i <= right; i++)
            {
                if (i % 2 == 0)
                {
                    ans.Add(i);
                }
            }
            return ans.ToArray();
        }

int factorizedGCD(int[] a, int[] b) {
  int j = 0,
      result = 1;
  for (int i = 0; i < a.length; i++) {
    while (j< b.length && a[i] > b[j]) {
      j++;
    }
    if (j < b.length && a[i] == b[j]) {
      result *= a[i];
      j++;
    }
  }
  return result;
}



int swapNeighbouringDigits(int n) {
     char[] ch = (n + "").ToCharArray();

            for (int i = 0; i + 1 < ch.Length; i+=2)
            {
                char temp = ch[i];
                ch[i] = ch[i + 1];
                ch[i + 1] = temp;
            }
            return int.Parse( new string(ch));
}




int isSumOfConsecutive2(int n) {
	     int cont = 0;
            for (int i = 1; i <= n; i++)
            {
                int sum = 0;
                for (int j = i; j <= n; j++)
                {
                    sum += j;
                    if (sum == n)
                    {
                        cont++;
                        break;
                    }
                    if (sum > n)
                    {
                        break;
                    }
                }
            }
            return cont-1;
}


bool isDiagonalMatrix(int[][] matrix) {
for (int i = 0; i < matrix.Length; i++)
            {
                for (int j = 0; j < matrix[i].Length; j++)
                {
                    if (i != j)
                    {
                        if (matrix[i][j] != 0) return false;
                    }
                }
            }
            return true; 
}


int reverseBits(int n) {
  int res = 0;
  for (int i = 0; i < 16; i++) {
    res = res * 2 + (n % 2);
    n /= 2;
  }
  return res;
}


typedef std::vector<std::string> elemT;
typedef std::vector<elemT> listT;
listT superResources(listT requests) {

  struct Helper {
    bool le(std::string const & a, std::string const & b) {
      return std::stoi(a) <= std::stoi(b);
    }
  };
  Helper h;

  if (requests.size() < 2) {
    return requests;
  }
  listT parts[2] = {
      listT(requests.begin(), requests.begin() + requests.size() / 2),
      listT(requests.begin() + requests.size() / 2, requests.end())
  };
  parts[0] = superResources(parts[0]);
  parts[1] = superResources(parts[1]);

  listT result;
  int idx[2] = {0, 0};
  int len[2] = {parts[0].size(), parts[1].size()};
  std::string last = "";
  while (idx[0] < len[0] || idx[1] < len[1]) {
    int k;
    if (idx[1] >= len[1] || idx[0] < len[0] &&
        h.le(parts[0][idx[0]][0], parts[1][idx[1]][0])) {
      k = 0;
    } else {
      k = 1;
    }
    elemT element = parts[k][idx[k]++];
    if (element[0] != last) {
      result.push_back(element);
      last = element[0];
    }
  }

  return result;
}


----------------------------------
   HashSet<int> primeFactors(int n)
        {
            HashSet<int> p = new HashSet<int>();
            // Print the number of 2s that divide n 
            while (n % 2 == 0)
            {
                //Console.Write(2 + " ");
                p.Add(2);
                n /= 2;
            }

            // n must be odd at this point. So we can 
            // skip one element (Note i = i +2) 
            for (int i = 3; i <= Math.Sqrt(n); i += 2)
            {
                // While i divides n, print i and divide n 
                while (n % i == 0)
                {
                    //Console.Write(i + " ");
                    p.Add(i);
                    n /= i;
                }
            }

            // This condition is to handle the case whien 
            // n is a prime number greater than 2 
            if (n > 2) p.Add(n);
                //Console.Write(n);

            return p;
        } 
      

         int leastCommonPrimeDivisor(int a, int b)
        {
            HashSet<int> pa = primeFactors(a);
            HashSet<int> pb = primeFactors(b);

            foreach (int item in pa)
            {
                if (pb.Contains(item))
                {
                    return item;
                }
            }

            return -1;
        } 


bool isLuckyNumber(int n) {
while (n > 0)
            {
                if (n % 10 != 4 && n % 10 != 7) return false;
                n /= 10;

            }
            return true;
}

  
    bool checkPalindrome(string inputString)
        {

            for (int i = 0, j = inputString.Length - 1; i < j; i++, j--)
            {
                if (inputString[i] != inputString[j]) return false;
            }
            return true; 
        }

String buildPalindrome(String st) {
  boolean canConvert;
  for (int i = st.length(); ; i++) {
    canConvert = true;
    for (int j = 0; j < i - j - 1; j++) {
      if (i - j - 1 < st.length() && st.charAt(j) != st.charAt(i - j - 1)) {
        canConvert = false;
        break;
      }
    }
    if (canConvert) {
      for (int j = st.length(); j < i; j++) {
        st += String.valueOf(st.charAt(i-j-1 ));
      }
      return st;
    }
  }
}


bool isMonotonous(int[] sequence) {
   bool incrementa = true;
            bool decrementa = true;
            for (int i = 0; i + 1 < sequence.Length; i++)
            {
                if (sequence[i + 1] <= sequence[i])
                {
                    incrementa = false;
                    break;
                }
            }
            for (int i = 0; i + 1 < sequence.Length; i++)
            {
                if (sequence[i + 1] >= sequence[i])
                {
                    decrementa  = false;
                    break;
                }
            }
            return incrementa || decrementa;
}

int kthDigit(int n, int k) {

  int numDigits = 0, number = n;
  while (number) {
    numDigits++;
    number /= 10;
  }

  int indexFromLast = numDigits -  k + 1;

  while (n) {
    if (--indexFromLast == 0) {
      return n % 10;
    }
    n /= 10;
  }

  return -1;
}


int[][] create2DArray(int[] lengths) {
      int[][] ans = new int[lengths.Length][];
            for (int i = 0; i < lengths.Length; i++)
            {
                ans[i] = new int[lengths[i]];
                for (int j = 0; j < lengths[i]; j++)
                {
                    ans[i][j] = j;
                }
            }
            return ans;
}

int digitDegree(int n){

  struct Helper {
    int digitSum(int n) {
      int sum = 0;
      while (n != 0) {
        sum += n % 10;
        n /= 10;
      }
      return sum;
    }
  };
  Helper h;

  int result = 0;

  while (n > 9) {
    result++;
    n = h.digitSum(n);
  }

  return result;
}


int kthDigit(int n, int k) {
  return k > (n + "").Length ? -1 : (n + "")[k - 1] - '0';
}


int numbersGrouping(int[] a) {
HashSet<int> hash = new HashSet<int>();

            for (int i = 0; i < a.Length; i++)
            {
                hash.Add( (a[i] - 1) / 10000);
            }
            return hash.Count + a.Length;
}


int arrayChange(int[] inputArray) {
            int ans = 0;
            for (int i = 1; i < inputArray.Length; i++)
            {
                if (inputArray[i - 1] >= inputArray[i])
                {
                    ans += inputArray[i - 1] - inputArray[i] + 1;
                    inputArray[i] = inputArray[i - 1] + 1;
                }
            }
            return ans;
}



int myMaxOfThree(int a, int b, int c) {
	    if (a > b && a > c) return a;
            if (b > c) return b;
            return c;
}



int kthDigit(int n, int k) {
      int rev = 0;

            while (n > 0)
            {
                rev = rev * 10 + n % 10;
                n /= 10;
            }
            int cont = 1;
            while (rev > 0)
            {
                if (cont == k)
                {
                    return rev % 10;
                }
                cont++;
                rev /= 10;
            }
            return -1;
}

bool cyclicSequence(int[] sequence) {
  int ind_min = Array.IndexOf(sequence, sequence.Min());

            int[] ordenado = new int[sequence.Length];
            int k = 0;
            for (int i = ind_min; i < sequence.Length; i++)
            {
                ordenado[k++] = sequence[i];
            }
            for (int i = 0; i < ind_min; i++)
            {
                ordenado[k++] = sequence[i];
            }
            for (int i = 0; i + 1 < ordenado.Length; i++)
            {
                if (ordenado[i + 1] <= ordenado[i])
                {
                    return false;
                }
            }
            return true;
}


int powerRecursive(int x, int exponent) {
  if (exponent == 0) {
    return 1;
  }
  else{
    return x *  powerRecursive( x,  exponent - 1);
  }
}



string swapCase(string text) {
     string s = "";
            for (int i = 0; i < text.Length; i++)
            {
                if (char.IsLower(text[i]))
                {
                    s += char.ToUpper(text[i]);
                }
                else
                {
                    s += char.ToLower(text[i]);
                }
            }
            return s;
}


string[] isDivisibleBy3(string inputString) {
     List<string> ans = new List<string>();
            for (char ch = '0'; ch <= '9'; ch++)
            {
                string s = inputString.Replace('*', ch);
                int sum = s.Sum(e => e - '0');
                if (sum % 3 == 0) ans.Add(s);
            }
            return ans.ToArray();
}
 

int divisorsPairs(int[] sequence) {
 HashSet<string> hash = new HashSet<string>();
            for (int i = 0; i < sequence.Length; i++)
            {
                for (int j = i + 1; j < sequence.Length; j++)
                {
                    int max = Math.Max(sequence[i], sequence[j]);
                    int min = sequence[i] + sequence[j] - max;

                    if (max % min == 0)
                    {
                        hash.Add(min + " " + max);
                    }
                }
            }
            return hash.Count;
}

 static bool areSimilarNumbers(int a, int b, int divisor)
        {
            return (a % divisor == 0 && b % divisor == 0) ||
                  (a % divisor != 0 && b % divisor != 0);
        }

        int maxDivisor(int left, int right, int divisor)
        {
            for (int i = right; i >= left; i--)
            {
                if (i % divisor == 0) return i;
            }
            return -1;
        }


boolean orthogonalLines(int[] line1, int[] line2) {
int sum=0;
    for(int i =0; i<line1.length-1; i++)
    {
        sum += line1[i] * line2[i];
    }
    if (sum ==0 )
    {
        return true;
    }
    else
    {
        return false;
    }
}


int sumOfMultiples(int n, int k) {
int sum = 0;
            for (int i = k; i <= n; i += k)
            {
                sum += i;
            }
            return sum;
}


int divNumber(int k, int l, int r)
        {
            int ans = 0;
            for (int i = l; i <= r; i++)
            {
                int div = 0;
                for (int j = 1; j <= i; j++)
                {
                    if (i % j == 0)
                    {
                        div++;
                    }

                }
                if (div == k)
                {
                    ans++;
                }

            }
            return ans;

        }


int numbersGrouping(int[] a) {
    List<int> nGroupList = new List<int>();
    for(int i=0;i<100000;i++) {
        nGroupList.Add(0);
    }
    int len = a.Length;
    for(int i=0;i<len;i++) {
        int index = (a[i]-1)/10000;
        if(nGroupList[index]==0)
            nGroupList[index]+=2;
        else
            nGroupList[index]++;
    }
     
    return nGroupList.Sum();
}

 static int numbersGrouping(int[] a) //funcionaria con numeros muy grandes
        {
            HashSet<int> hs = new HashSet<int>();
            foreach (int n in a)
            {
                //hs.Add(grupo(elem));
                int g1 = 0;
                if (n <= 10000)
                {
                    hs.Add(0);
                    continue;
                    //return 0;
                }

                string ns = n.ToString();
                string g = ns.Substring(0, ns.Length - 5 + 1);

                string resto = ns.Substring(ns.Length - 5, 5);
                //Console.WriteLine(resto);

                string ultimo = "";
                ultimo += resto[0].ToString() + new string('0', resto.Length - 1);
                // Console.WriteLine(ultimo);

                g1 = int.Parse(g);
                if (resto == ultimo)
                {
                    g1--;
                }

                hs.Add(g1);
            }
            return hs.Count + a.Length;
        }


static  bool isIncreasingDigitsSequence(int n)
        {
            int dig = n % 10;
            n /= 10;
            while (n > 0)
            {
                if (n % 10 >= dig)
                {
                    return false;
                }
                dig = n % 10;
                n /= 10;
            }
            return true;
        }

int factorialTrailingZeros(int n) {
int result = 0;
  for (int i = 5; i <= n; i += 5) {
    int number = i;
    while (number % 5 == 0) {
      number /= 5;
      result++;
    }
  }
  return result;
}

double[] quadraticEquation(int a, int b, int c) {
	    int discriminant = b * b - 4 * a * c;
            if (discriminant < 0)
            {
                List<Double> empty = new List<Double>();
                return empty.ToArray();
            }
            if (discriminant == 0)
            {
                List<Double> answer = new List<Double>();
                answer.Add(-b / (2.0 * a));
                return answer.ToArray();
            }
            List<Double> roots = new List<Double>();
            roots.Add((-b - Math.Sqrt(discriminant)) / (2.0 * a));
            roots.Add((-b + Math.Sqrt(discriminant)) / (2.0 * a));
            if (roots[0] > roots[1])
            {
                double tmp = roots[1];
                roots[1] = roots[0];
                roots[0] = tmp;
            }
            return roots.ToArray();
}


 static int sumUpDigits(string inputString)
        {
            int sum = 0;
            for (int i = 0; i < inputString.Length; i++)
            {
                if (inputString[i] >= '0' && inputString[i] <= '9')
                {
                    sum += (inputString[i] - '0');
                }
            }
            return sum;
        }


 public static int exerciseElaboration(int p, int n) {

        StringBuilder sb = new StringBuilder();
        sb.append(p);
        for (int i = 0; i < n; i++)
            sb.append('0');
        sb.append(p);
        BigInteger b = new BigInteger(sb.toString());
        String s = b.multiply(b).toString();
        int result = 0;
        for (char c : s.toCharArray())
            result += c - '0';

        return result;

    }

std::string knapsackLight2(int weight1, int weight2, int maxW) {
if (weight1 + weight2 <= maxW) {
    return "both";
  }
  if (std::min(weight1, weight2) > maxW) {
    return "none";
  }
  if (std::max(weight1, weight2) <= maxW) {
    return "either";
  }
  if (weight1 <= maxW) {
    return "first";
  }
  return "second";
}



string concatenationProcess(string[] initialArray) {
            List<string> r = new List<string>(initialArray);
            while (r.Count > 1)
            {
                int min = int.MaxValue;
                int mini = -1;
                for (int i = 0; i < r.Count; i++)
                {
                    if (r.ElementAt(i).Length < min)
                    {
                        min = r.ElementAt(i).Length;
                        mini = i;
                    }
                }
                int min2 = int.MaxValue;
                int mini2 = -1;
                for (int i = r.Count - 1; i >= 0; i--)
                {
                    if (i != mini && r.ElementAt(i).Length < min2)
                    {
                        min2 = r.ElementAt(i).Length;
                        mini2 = i;
                    }
                }
                string neu = r.ElementAt(mini) + r.ElementAt(mini2);
                if (mini < mini2)
                {
                    r.RemoveAt(mini2);
                    r.RemoveAt(mini);
                }
                else
                {
                    r.RemoveAt(mini);
                    r.RemoveAt(mini2);
                }
                r.Add(neu);
            }
            return r.First();
}

int countIncreasingSequences(int n, int k) {
    int u=1;
    for (int i=0; i<n; i++)
        u=((k-i)*u)/(i+1);
    return u;
}


string removeDuplicateCharacters(string str) {
Dictionary<char, int> hash = new Dictionary<char, int>();
            for (int i = 0; i < str.Length; i++)
            {
                if (hash.ContainsKey(str[i]))
                {
                    hash[str[i]]++;
                }
                else
                {
                    hash[str[i]] = 1;
                }
            }

            string s = "";
            for (int i = 0; i < str.Length; i++)
            {
                if (hash[str[i]] == 1)
                {
                    s += str[i];
                }
            }
            return s;
}


    private static int quasifactorial(int n) {
        int answer = 1;
        for (int i = 2; i <= n; ++i) {
            answer *= i;
            --answer;
        }
        return answer;
    }


boolean chessBoardCellColor(String cell1, String cell2) {
 if((cell1.charAt(0) + cell1.charAt(1)) % 2 == 0 &&
        		(cell2.charAt(0) + cell2.charAt(1)) % 2 == 0 ||
        		(cell1.charAt(0) + cell1.charAt(1)) % 2 != 0 &&
        		(cell2.charAt(0) + cell2.charAt(1)) % 2 != 0) {
        	return true;

        }
        return false;
}



bool isIPv4Address(std::string inputString) {

  int currentNumber = 0;
  bool emptyField = true;
  int countNumbers = 0;

  inputString += '.';

  for (int i = 0; i < inputString.size(); i++) {
    if (inputString[i] == '.') {
      if (emptyField) {
        return false;
      }
      countNumbers++;
      currentNumber = 0;
      emptyField = true;
    }
    else {
      int digit = inputString[i] - '0';
      if (digit < 0 || digit > 9) {
        return false;
      }
      emptyField = false;
      currentNumber = currentNumber * 10 + digit;
      if (currentNumber > 255) {
        return false;
      }
    }
  }
  return countNumbers == 4;
}


private static int[] setUnion(int[] A, int[] B) {

        ArrayList<Integer> C = new ArrayList<>();
        int pos_b = 0;

        Arrays.sort(A);
        Arrays.sort(B);

        for (int pos_a = 0; pos_a < A.length; pos_a++) {
            while (pos_b < B.length && B[pos_b] < A[pos_a]) {
                C.add(B[pos_b]);
                pos_b++;
            }
            C.add(A[pos_a]);
            if (pos_b < B.length && A[pos_a] == B[pos_b]) {
                pos_b++;
            }
        }
        while (pos_b < B.length) {
            C.add(B[pos_b]);
            pos_b++;
        }

        int[] res = new int[C.size()];
        for (int i = 0; i < res.length; i++) {
            res[i] = C.get(i);
        }

        return res;
    }


 static int chartFix(int[] chart)
        {
            int[] DP = new int[chart.Length];
            int maxLength = 1;
            DP[0] = 1;

            for (int i = 1; i < chart.Length; i++)
            {
                DP[i] = 1;

                for (int j = i - 1; j >= 0; j--)
                    if (DP[j] + 1 > DP[i] && chart[j] < chart[i])
                    {
                        DP[i] = DP[j] + 1;
                    }

                if (DP[i] > maxLength)
                {
                    maxLength = DP[i];
                }
            }

            return chart.Length - maxLength;
        }

bool areEquallyStrong(int yl, int yr, int fl, int fr) {
    return new HashSet<int>(){yl,yr}.SetEquals(new HashSet<int>(){fl,fr});
}


int sequenceElement(int[] a, int n) {
    var s = new Dictionary<int, int>();
    for(int i=0; i<4686; i++)
        s[i] = i<5 ?  a[i] : (s[i-1] + s[i-2] + s[i-3] + s[i-4] + s[i-5]) % 10;
    return s[n%4686];
}



typedef std::vector<std::vector<int>> matrix;
std::vector<int> easyAssignmentProblem(matrix skills) {
  return skills[0][0] + skills[1][1] > skills[0][1] + skills[1][0] ?
        std::vector<int>({1,2}) : std::vector<int>({2, 1});
}



int minimalNumberOfCoins(std::vector<int> coins, int price) {

  int result = 0;

  for (int i = (int)coins.size() - 1; i >= 0; i--) {
    result += price / coins[i];
    price %= coins[i];
  }

  if (price) {
    return -1;
  }
  return result;
}


long[] removeDigits(long n, int k) {
    var a = new List <long>();
    var s = n.ToString();
    for (int i=0; i<s.Length-k+1; i++)
        a.Add(long.Parse(s.Substring(i,k)));
    return new long[]{a.Min(), a.Max()};
}

function bfsComponentSize(matrix) {
 var visited = [],
    queue = [],
    componentSize = 0;
  for (var i = 0; i < matrix.length; i++) {
    visited.push(false);
  }
  visited[1] = true;
  queue.push(1);
  while (queue.length) {
    var currentVertex = queue.shift();
    visited[currentVertex] = true;
    componentSize++;
    for (var nextVertex = 0; nextVertex < matrix.length; nextVertex++) {
      if (matrix[currentVertex][nextVertex] && !visited[nextVertex]) {
        visited[nextVertex] = true;
        queue.push(nextVertex);
      }
    }
  }
  return componentSize;
}



int numberOfSolutions(int n) {

  int result = 0;
  for (int a = n + 1; a < 2 * n; a++) {
    if ((a * n) % (a - n) == 0) {
      result++;
    }
  }

  return result * 2 + 1;
}



string capitalizeVowelsRegExp(string input) {
string s = "";
            for (int i = 0; i < input.Length; i++)
            {
                if ("aeiouy".Contains(input[i]))
                {
                    if (char.IsLower(input[i]))
                    {
                        s += char.ToUpper(input[i]);
                    }
                }
                else
                {
                    s += input[i];
                }
            }
            return s;
}



  int differentSubstrings(string inputString)
        {
            HashSet<string> hash = new HashSet<string>();
            for (int i = 0; i < inputString.Length; i++)
            {
                for (int j = i; j < inputString.Length; j++)
                {
                    hash.Add(inputString.Substring(i, j - i + 1));
                }

            }
            return hash.Count;
        }


int[] threeAndFour(int n) {
	    List<int> ans = new List<int>();
            for (int i = 0; i < n; i++)
            {
                if (i % 3 == 0 && i % 4 == 0)
                {
                    ans.Add(i);
                }
            }
            return ans.ToArray();
}



int sumBelowBound(int bound) {
 int sum = 0;
            for (int i = 1; ; i++)
            {
                if (sum + i > bound) return i-1;
                
                    sum += i;

            }
}


string[] sortByLength(string[] inputArray) {
	    for (int i = 1; i < inputArray.Length; i++)
            {
                int indice = i;
                while (indice > 0 && inputArray[indice - 1].Length > inputArray[indice].Length)
                {
                    string temp = inputArray[indice - 1];
                    inputArray[indice - 1] = inputArray[indice];
                    inputArray[indice] = temp;
                    indice--;
                }
            }
            return inputArray;
}


int divisorsSubset(int[] subset, int n) {
	int c = 0;
        for (int i = 1; i <= n; i++) {
            bool ch = true;
            foreach (int aSubset in subset) {
                if (i % aSubset != 0)
                    ch = false;
            }
            if (ch) c++;
        }
        return c;
}


int[] theJanitor(string word) {
	    int[] ans = new int[26];
            int i = 0;
            for (char ch = 'a'; ch <= 'z'; ch++)
            {


                int last = word.LastIndexOf(ch);
                int first = word.IndexOf(ch);
                int dist = 0;
                if (last != -1) dist = last - first + 1;
                    
                ans[i++] = dist;

            }
            return ans;
}

char fractionComparison(int[] a, int[] b) {
    double da = (double)a[0] / (double)a[1];
            double db = (double)b[0] / (double)b[1];

            if (da == db)
            {
                return '=';
            }
            if (da > db) return '>';
            return '<';
}

int maxZeros(int n) {
	int answer = 0,
                maxZeros = 0;
        for (int k = 2; k <= n; k++) {
            int numZeros = 0,
                    value = n;
            while (value != 0) {
                if (value % k == 0) {
                    numZeros++;
                }
                value /= k;
            }
            if (numZeros > maxZeros) {
                maxZeros = numZeros;
                answer = k;
            }
        }
        return answer;
}



    static int[][] neighboringCells(int[][] matrix)
        {
            int[][] ans = new int[matrix.Length][];
            for (int i = 0; i < matrix.Length; i++)
            {
                ans[i] = new int[matrix[i].Length];
            }

            for (int i = 0; i < matrix.Length; i++)
            {
                for (int j = 0; j < matrix[i].Length; j++)
                {
                    if (i - 1 >= 0) ans[i][j]++;
                    if (i + 1 < matrix.Length) ans[i][j]++;
                    if (j - 1 >= 0) ans[i][j]++;
                    if (j + 1 < matrix[i].Length) ans[i][j]++;
                }
            }
            return ans;

        }



   int differentValuesInMultiplicationTable2(int n, int m)
        {
            HashSet<int> hash = new HashSet<int>();
            for (int i = 1; i <= n; i++)
            {
                for (int j = 1; j <= m; j++)
                {
                    hash.Add(i * j);
                }

            }
            return hash.Count;
        }



int arrayMinimumAboveBound(int[] inputArray, int bound) {
     int dif = int.MaxValue;
            int ans = -1;
            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i] > bound)
                {
                    if (inputArray[i] - bound < dif)
                    {
                        dif = inputArray[i] - bound;
                        ans = inputArray[i];
                    }
                    //dif = inputArray[i] - bound;
                }
            }
            return ans;
}

static bool isLowerTriangularMatrix(int[][] matrix)
        {
            for (int i = 0; i < matrix.Length; i++)
            {
                for (int j = i; j < matrix[i].Length; j++)
                {
                    if (matrix[i][j] != 0)
                    {
                        return false;
                    }

                }
            }
            return true;
        }

bool isLowerTriangularMatrix(int[][] matrix) {
    for (int i = 0; i < matrix.Length; i++)
            {
                for (int j = i +1; j < matrix[i].Length; j++)
                {
                    if (matrix[i][j] != 0)
                    {
                        return false;
                    }

                }
            }
            return true;
}


  static int[] extractMatrixColumn(int[][] matrix, int column)
        {
            int[] ans = new int[matrix.Length];
            for (int i = 0; i < matrix.Length; i++)
            {
                ans[i] = matrix[i][column];
            }
            return ans;
        }

------------------------

static bool esPalin(char[] ch)
        {
            int i = 0, j = ch.Length - 1;

            while (i < j)
            {
                if (ch[i] != ch[j]) return false;
                i++;
                j--;
            }
            return true;
        }

        static bool isOneSwapEnough(string inputString)
        {
            char[] ch = inputString.ToCharArray();
            if (esPalin(ch)) return true;
            for (int i = 0; i < ch.Length - 1; i++)
            {
                for (int j = i + 1; j < ch.Length; j++)
                {
                    char temp = ch[i];
                    ch[i] = ch[j];
                    ch[j] = temp;
                    if (esPalin(ch)) return true;
                    temp = ch[j];
                    ch[j] = ch[i];
                    ch[i] = temp;
                }
            }
            return false;
        }



-----------------------------

bool isPermutation(int n, int[] inputArray) {
            bool[] cont = new bool[Math.Max( n + 1, inputArray.Max()+1)];

            for (int i = 0; i < inputArray.Length; i++)
            {
                if (inputArray[i] > 0)
                {
                    cont[inputArray[i]] = true;
                }
            }

            for (int i = 1; i <= n; i++)
            {
                if (cont[i] == false)
                {
                    return false;
                }
            }
            return true;
}


bool isPermutation(int n, int[] inputArray) {
      HashSet<int> hash = new HashSet<int>(inputArray);

            for (int i = 1; i <= n; i++)
            {
                if (!hash.Contains(i))
                {
                    return false;
                }
            }
            return true;
}


  int rightmostRoundNumber(int[] inputArray)
        {
            for (int i = inputArray.Length - 1; i >= 0; i--)
            {
                if (inputArray[i] % 10 == 0) return inputArray[i];
            }
            return -1;
        }


int deleteDigit(int n) {
int max = int.MinValue;
            string s = n.ToString();
            for (int i = 0; i < s.Length; i++)
            {
                max = Math.Max(max, int.Parse(s.Remove(i, 1)));
            }
            return max;
}

int cyclicString(string s) {
List<string> mismas = new List<string>();

            for (int i = 0; i < s.Length; i++)
            {
                string subs = "";
                for (int j = i + 1; j < s.Length; j++)
                {
                    if (s[i] == s[j])
                    {
                        subs = s.Substring(i, j - i );
                        //break;
                        mismas.Add(subs);
                    }
                }
            }

            foreach (string item in mismas)
            {
                string concat = "";
                for (int i = 0; concat.Length < s.Length; i++)
                {
                    concat += item;
                }
                if (concat.Contains(s))
                {
                    return item.Length;
                }
            }

            return s.Length;
}



        int countDistantPairs(string inputString, int distance)
        {
            int cont = 0;
            for (int i = 0; i + distance + 1 < inputString.Length; i++)
            {
                if (inputString[i] == inputString[i + distance + 1])
                {
                    cont++;
                }
            }
            return cont;

        }


std::string biggerWord(std::string w) {

  int leftSwap = -1;
  for (int i = (int)w.size() - 2; i >= 0; i--) {
    if (w[i] < w[i + 1]) {
      leftSwap = i;
      break;
    }
  }
  if (leftSwap == -1) {
    return "no answer";
  }

  int rightSwap = (int)w.size() - 1;
  while (w[leftSwap] >= w[rightSwap]) {
    rightSwap--;
  }
  std::swap(w[leftSwap++], w[rightSwap]);
  rightSwap = (int)w.size() - 1;
  while (leftSwap < rightSwap) {
    std::swap(w[leftSwap++], w[rightSwap--]);
  }
  return w;
}


    bool evenDigitsOnly(int n)
        {
            string impares = "13579";
            string s = n.ToString();

            for (int i = 0; i < s.Length; i++)
            {
                if (impares.Contains(s[i])) return false;
            }
            return true;
        }

 private static boolean noAdjacentBits(int a) {

        int lastBit = 0,
                idx = 0;
        while ((1 << idx) <= a) {
            int curBit = (a >> idx) & 1;
            if (lastBit == 1 && curBit == 1) {
                return false;
            }
            lastBit = curBit;
            idx++;
        }

        return true;
    }


bool passwordCheckRegExp(string inputString) {
    if (inputString.Length >= 5)
            {
                bool capital = false;
                bool small = false;
                bool digit = false;

                for (int i = 0; i < inputString.Length; i++)
                {
                    if (char.IsUpper(inputString[i]))
                    {
                        capital = true;
                    }
                    if (char.IsLower(inputString[i]))
                    {
                        small = true;
                    }
                    if (char.IsDigit(inputString[i]))
                    {
                        digit = true;
                    }
                }

                return capital && small && digit;
            }
            return false;
}


static string angleType(int measure)
        {
            if (measure < 90)
            {
                return "acute";
            }
            else if (measure == 90)
            {
                return "right";
            }
            else if (measure < 180)
            {
                return "obtuse";
            }

            return "straight";

        }

int[] quickSort(int[] a, int l, int r) {

  if (l >= r) {
    return a;
  }

  int x = a[l];
  int i = l;
  int j = r;

  while (i <= j) {
    while(a[i] < x) {
      i++;
    }
    while (a[j] > x) {
      j--;
    }
    if (i <= j) {
      int t = a[i];
      a[i] = a[j];
      a[j] = t;
      i++;
      j--;
    }
  }

  quickSort(a, l, j);
  quickSort(a, i, r);

  return a;
}


static int fibonacciIndex(int n)
        {

            if (n == 1) return 0;

            List<int> fib = new List<int>();
            fib.Add(0);
            fib.Add(1);

            int len = 1;
            int i = 2;
            for ( ; ; i++)
            {
                fib.Add(fib[i - 1] + fib[i - 2]);
                len = fib[i].ToString().Length;
                if (len == n) break;
            }
            return i;

        }


int largestFullBinaryTree(std::vector<int> parent) {

  struct Graph {
    std::vector<std::vector<int>> edges;
    int maxBinTree;

    Graph(std::vector<int> const & parent) {
      maxBinTree = 1;
      edges = std::vector<std::vector<int>>(parent.size());
      for (int i = 1; i < parent.size(); i++) {
        edges[parent[i]].push_back(i);
      }
    }

    int dfs(int v) {
      int firstMax = -1;
      int secondMax = -1;
      for (int u : edges[v]) {
        int curMax = dfs(u);
        if (curMax > firstMax) {
          secondMax = firstMax;
          firstMax = curMax;
        } else if (curMax > secondMax) {
          secondMax = curMax;
        }
      }
      if(secondMax==-1) return 1;
      int result = 1 + firstMax + secondMax;
      if (result > maxBinTree) {
        maxBinTree = result;
      }
      return result;
    }
  };

  Graph g(parent);
  g.dfs(0);
  return g.maxBinTree;
}


bool isPower(int n) {
if(n==1)
        return true;
    for(int index=2;index<=Math.Sqrt(n);index++) {
        for(int power=2;power<=Math.Sqrt(n);power++) {
            if(Math.Pow(index,power)==n)
                return true;
        }
    }
    return false;
}

  static string getMonthName(int mo)
        {
            if (mo < 1 || mo > 12) return "invalid month";
            string[] meses = { "Jan", "Feb",   "Mar",  "Apr",   "May",  "Jun",   "Jul", "Aug",  "Sep",  "Oct",
                              "Nov",  "Dec"  };

            return meses[mo - 1];
        }



        static int[] digitDifferenceSort(int[] a)
        {
            int[] difs = new int[a.Length];
            for (int i = 0; i < a.Length; i++)
            {
                int min = 10;
                int max = -1;

                int copia = a[i];
                while (copia > 0)
                {
                    min = Math.Min(min, copia % 10);
                    max = Math.Max(max, copia % 10);
                    copia /= 10;
                }
                int dif = max - min;
                difs[i] = dif;
            }

            for (int i = 0; i < a.Length - 1; i++)
            {
                for (int j = i + 1; j < a.Length; j++)
                {
                    if (difs[i] > difs[j])
                    {
                        int temp = a[i];
                        a[i] = a[j];
                        a[j] = temp;

                        int temp_difs = difs[i];
                        difs[i] = difs[j];
                        difs[j] = temp_difs;
                    }
                    else if (difs[i] == difs[j])
                    {
                        int temp = a[i];
                        a[i] = a[j];
                        a[j] = temp;

                        int temp_difs = difs[i];
                        difs[i] = difs[j];
                        difs[j] = temp_difs;

                    }
                }

            }
            return a;
        }




int differentDigitsNumberSearch(int[] inputArray) {
	    for (int i = 0; i < inputArray.Length; i++)
            {
                int copia = inputArray[i];
                HashSet<int> digs = new HashSet<int>();
                while (copia > 0)
                {
                    if (!digs.Add(copia % 10))
                    {
                        break;
                    }
                    copia /= 10;
                }
                if (copia ==0 ) return inputArray[i];

            }
            return -1;
}


int createAnagram(string s, string t) {
	    int[] hash_s = new int[26];
            int[] hash_t = new int[26];

            for (int i = 0; i < s.Length; i++)
            {
                hash_s[s[i] - 'A']++;
            }

            for (int i = 0; i < t.Length; i++)
            {
                hash_t[t[i] - 'A']++;
            }

            int comun = 0;
            for (int i = 0; i < 26; i++)
            {
                comun += Math.Min(hash_s[i], hash_t[i]);

            }
            return s.Length - comun;
}


int firstMultiple2(int[] divisors, int start) {
      for (int i = start; ; i++)
            {
                int j = 0;
                for (; j < divisors.Length ; j++)
                {
                    if (i % divisors[j] == 0) return i;
                }

            }
            return -1;
}


   int firstMultiple(int[] divisors, int start)
        {
            for (int i = start; ; i++)
            {
                int j = 0;
                for (; j < divisors.Length ; j++)
                {
                    if (i % divisors[j] != 0) break;
                }
                if (j == divisors.Length) return i;
            }
        }

  static  string formatString(string input)
        {

            string[] a = input.Split(' ');

            string s = "";
            for (int i = 0; i < a.Length; i++)
            {
                if (a[i].Length > 0)
                {
                    s += a[i] + " ";
                }
            }
            return s.Trim();

        }


static int makeArrayConsecutive2(int[] statues)
        {
            int min = statues.Min();
            int max = statues.Max();

            HashSet<int> hash = new HashSet<int>(statues);

            List<int> ans = new List<int>();
            for (int i = min; i <= max; i++)
            {
                if (!hash.Contains(i))
                {
                    ans.Add(i);
                }
            }

            return ans.Count;
        }

int SumDig(int n)
        {
            int sum = 0;
            while (n > 0)
            {
                sum += n % 10;
                n /= 10;
            }
            return sum;
        }

     int[] digitalSumSort(int[] a)
        {
            int[] sd = new int[a.Length];
            for (int i = 0; i < a.Length; i++)
            {
                sd[i] = SumDig(a[i]);
            }

            for (int i = 0; i < a.Length - 1; i++)
            {
                for (int j = i + 1; j < a.Length; j++)
                {
                    int s_i = SumDig(a[i]);
                    int s_j = SumDig(a[j]);
                    if ( s_i > s_j)
                    {
                        int temp = a[i];
                        a[i] = a[j];
                        a[j] = temp;
                    }
                    else if (s_i == s_j)
                    {
                        if (a[i] > a[j])
                        {
                            int temp = a[i];
                            a[i] = a[j];
                            a[j] = temp;
                        }
                    }
                }
            }
            return a;
        }



int differentValuesInMultiplicationTable(int n, int m)
        {

            HashSet<int> hash = new HashSet<int>();

            for (int i = 1; i <= n; i++)
            {
                for (int j = 1; j <= m; j++)
                {
                    hash.Add(i * j);
                }

            }
            return hash.Count;


        }



        bool isCorrectSentence(string inputString)
        {
            return char.IsLetter(inputString[0]) && char.IsLetter(inputString[inputString.Length - 1]);
        }

	bool isCorrectSentence(string inputString) {
 		return char.IsUpper(inputString[0]) &&  inputString[inputString.Length - 1] =='.';
	}

int depositProfit(int deposit, int rate, int threshold) {
 double sum = 0.0;
            sum = deposit + (deposit * rate/100.0);
            int i =1; 
            for (; ; i++)
            {
                if (sum >= threshold) break;
                sum = sum + (sum * rate / 100.0);

            }

            return i;
}


bool regularBracketSequence1(string sequence) {
   Stack<char> pila = new Stack<char>();

            for (int i = 0; i < sequence.Length; i++)
            {
                if (sequence[i] == '(')
                {
                    pila.Push(sequence[i]);
                }
                else
                {
                    if (pila.Count == 0) return false;

                    pila.Pop();
                }

            }
            return pila.Count == 0;
}



 int[] extractEachKth(int[] inputArray, int k)
        {
            List<int> ans = new List<int>();

            for (int i = 0; i < inputArray.Length; i++)
            {
                if ((i + 1) % k == 0)
                {
                    ans.Add(inputArray[i]);
                }

            }
            return ans.ToArray();
        }

HashSet<int> primeFactors(int n)
	


int swapNeighbouringDigits(int n) {
string s = n + "";
            char[] ch = s.ToCharArray();
            for (int i = 0; i + 1 < s.Length; i+=2)
            {
                char temp = ch[i];
                ch[i] = ch[i + 1];
                ch[i + 1] = temp;
            }
            return int.Parse(new string(ch));
}


int numberOfTriangles2(int[] sticks) {
  int cont = 0;
            for (int i = 0; i < sticks.Length; i++)
            {
                for (int j = i + 1; j < sticks.Length; j++)
                {
                    for (int k = j + 1; k < sticks.Length; k++)
                    {
                        if (sticks[i] + sticks[j] > sticks[k])
                        {
                            cont++;
                        }

                    }
                }

            }
            return cont;
}



double[] quadraticEquation(int a, int b, int c) {
int discriminant = b * b - 4 * a * c;
        if (discriminant < 0) {
            ArrayList<Double> empty = new ArrayList<>();
            return empty;
        }
        if (discriminant == 0) {
            ArrayList<Double> answer = new ArrayList<>();
            answer.add(-b / (2.0 * a));
            return answer;
        }
        ArrayList<Double> roots = new ArrayList<>();
        roots.add((-b - Math.sqrt(discriminant)) / (2.0 * a));
        roots.add((-b + Math.sqrt(discriminant)) / (2.0 * a));
        if (roots.get(0) > roots.get(1)) {
            double tmp = roots.get(1);
            roots.set(1, roots.get(0));
            roots.set(0, tmp);
        }
        return roots;
}

int differentValues(int[] a, int d) {
 int cerca_min = int.MaxValue;
            int min_dif = -1;
            for (int i = 0; i < a.Length; i++)
            {

                for (int j = i + 1; j < a.Length; j++)
                {
                    int dif = Math.Abs(a[i] - a[j]);

                    if (dif <= d)
                    {
                        int cerca_local = d - dif;

                        if (cerca_local < cerca_min)
                        {
                            cerca_min = cerca_local;
                            min_dif = dif; 
                        }
                       
                    }
                }
            }

            return min_dif;
}


string deleteWhitespaces(string inputStr)
        {
            string s = "";
            for (int i = 0; i < inputStr.Length; i++)
            {
                if (inputStr[i] != ' ') s += inputStr[i];
            }
            return s;
        }


        int digitSum(int n)
        {
            int sum = 0;
            while (n > 0)
            {
                sum += n % 10;
                n /= 10;
            }
            return sum;
        }



int[] maxSumSegments(int[] inputArray) {
    var result = new List<int>();
    var n = inputArray.Length;
    var store = new int[n];
    
    store[0] = inputArray[0];
    
    for (int i = 1; n > i; ++i) {
        store[i] = inputArray[i] + store[i - 1];
    }
    
    for (int i = 0; n > i; ++i) {
        result.Add(getMaxSumIndex(i, store));
    }
    
    return result.ToArray();
}

int getMaxSumIndex(int n, int[] sums) {
    var l = 0;
    var r = l + n;
    var result = 0;
    var sum = int.MinValue;
    
    while (sums.Length > r) {
        var temp = 0 == l ? (sums[r]) : (sums[r] - sums[l - 1]);
        
        if (sum < temp) {
            sum = temp;
            result = l;
        }
        
        ++l;
        ++r;
    }
    
    return result;
}


 static int firstNotDivisible(int[] divisors, int start)
        {

            for (int i = start; ; i++)
            {
                int j = 0;
                for ( ; j < divisors.Length; j++)
                {
                    if (i % divisors[j] == 0)
                    {
                        break;
                    }
                }
                if (j == divisors.Length)
                {
                    return i;
                }

            }
            
        }



int lrSegmentNumber(int l, int r) {
   string s = "";
            for (int i = l; i <= r; i++)
            {
                s += i + "";
            }
            return int.Parse(s);
}



int smallestUnusualNumber(string a) {
    if (a.IndexOf('0')>=0) return 0;
    int s=0;
    int p=1;
    for (int i=0; i<a.Length; i++){
        s=s+(a[i]-'0');
        p=p*(a[i]-'0');
        if (p>1000000) return 10-a[a.Length-1]+'0';
    }
    if (s>p) return 0;
    else return 10-a[a.Length-1]+'0';
}

string reversedSumOfDigits(int p, int n) {
    int m=n;
    if (n*9<p)return "-1";
    if (p==0&&n>1)return "-1";
    string r="";
    while (p>9){
        r+="9";
        p-=9;
        n--;
    }
    if (n>1) r=(p-1)+r;
    else return p+r;
    r=r.PadLeft(m-1,'0');
    return "1"+r;
}

bool isTournament(int n, int[] fromV, int[] toV) {
    var a = Enumerable.Range(1, n).ToDictionary(c => c, c=> new HashSet<int>(){c});
    
    for (int i = 0; i < fromV.Length; i++)
    {
        var f = fromV[i];
        var t = toV[i];
        
        if (!a[f].Add(t))
            return false;
        
        if (!a[t].Add(f))
            return false;
    }
    
    return a.All(kv => kv.Value.Count == n);
}


def combs(comb1, comb2):

    def getMask(comb):
        mask = 0
        for i in range(0, len(comb)):
            c = comb[i]
            mask = (mask << 1) + (c == '*')
        return mask

    m1 = getMask(comb1)
    m2 = getMask(comb2)
    len1 = len(comb1)
    len2 = len(comb2)
    answer = len1 + len2
    for i in range(-len1, len2 + 1):
        if i < 0:
            tmp = m2 << (-i) & m1
            length = max(-i + len2, len1)
        else:
            tmp = m1 << i & m2
            length = max(i + len1, len2)
        if tmp == 0 and answer > length:
            answer = length

    return answer


def pairOfShoes(shoes):
    leftShoes = []
    rightShoes = []
    for i in range(len(shoes)):
        if shoes[i][0] == 0:
            leftShoes.append(shoes[i][1])
        else:
            rightShoes.append(shoes[i][1])
    leftShoes.sort()
    rightShoes.sort()
    if len(leftShoes) != len(rightShoes):
        return False
    for i in range(len(leftShoes)):
        if leftShoes[i] != rightShoes[i]:
            return False
    return True


int[] maximalAllowableSubarrays(int[] inputArray, int maxSum) {
	    List<int> lista = new List<int>();
            for (int i = 0; i < inputArray.Length; i++)
            {
                int sum = 0;
                
                int j = i;
                while (j < inputArray.Length && sum + inputArray[j] <= maxSum)
                {
                    //break;
                    //if (j >= inputArray.Length) break;
                    sum += inputArray[j];
                    j++;
                }

                lista.Add(j-1);
            }

            return lista.ToArray();
}

int arrayMaximalAdjacentDifference(int[] inputArray) {
    int max_dif = 0;
            for (int i = 0; i + 1 < inputArray.Length; i++)
            {
                max_dif = Math.Max(max_dif, Math.Abs(inputArray[i] - inputArray[i + 1]));
            }
            return max_dif;
}


int[][] reverseOnDiagonals(int[][] matrix) {
 for (int i = 0; i < matrix.Length / 2; i++)
            {
                //int temp = matrix[i][matrix.Length - i - 1];
                //matrix[i][matrix.Length - i - 1] = matrix[i][i];
                //matrix[i][i] = temp;

                int temp2 = matrix[i][matrix.Length - i - 1];
                matrix[i][matrix.Length - i - 1] = matrix[matrix.Length - i - 1][i];
                matrix[matrix.Length - i - 1][i] = temp2;

                int temp = matrix[i][i];
                matrix[i][i] = matrix[matrix.Length - i - 1][matrix.Length - i - 1];
                matrix[matrix.Length - i - 1][matrix.Length - i - 1] = temp;

                

            }
            return matrix;
}


boolean subsetsSequence(int[][] sets) {

  class Helper {
    boolean isSubset(int[] setA, int[] setB) {
      int j = 0;
      for (int i = 0; i < setB.length; i++) {
        if (j < setA.length && setA[j] == setB[i]) {
          j++;
        }
      }
      if (j == setA.length) {
        return true;
      }
      else {
        return false;
      }
    }
  };

  Helper h = new Helper();

  int[] supersets = new int[sets.length];

  for (int i = 0; i < sets.length; i++) {
    Arrays.sort(sets[i]);
  }

  for (int i = 0; i < sets.length; i++) {
    for (int j = i + 1; j < sets.length; j++) {
      if (h.isSubset(sets[i], sets[j])) {
                    supersets[i]++;
                }
      if (h.isSubset(sets[j], sets[i])) {
        supersets[j]++;
      }
    }
  }

  Arrays.sort(supersets);

  for (int i = 0; i < sets.length; i++) {
    if (supersets[i] < i) {
      return false;
    }
  }

  return true;
}


public bool RobotWalk(int[] a){

       int minX = 0;
        int minY = -1;
        int maxX = int.MaxValue;
        int maxY = int.MaxValue;

        int x = 0;
        int y = 0;

        for (int i = 0; i < a.Length; i++) {
            switch (i % 4) {

                case 0:
                    y += a[i];
                    if (y >= maxY) {
                        return true;
                    }
                    maxY = y;
                    break;

                case 1:
                    x += a[i];
                    if (x >= maxX) {
                        return true;
                    }
                    maxX = x;
                    break;

                case 2:
                    y -= a[i];
                    if (y <= minY) {
                        return true;
                    }
                    minY = y;
                    break;

                case 3:
                    x -= a[i];
                    if (x <= minX) {
                        return true;
                    }
                    minX = x;
                    break;
            }
        }

        return false;
    
}


 
 bool isArithmeticProgression(int[] sequence)
        {
            int dif = sequence[1] - sequence[0];

            for (int i = 1; i < sequence.Length; i++)
            {
                if (sequence[i] - sequence[i - 1] != dif) return false;

            }
            return true;
        }


int countIncreasingSequences(int n, int k) {

  /*
   * vector dp (short for dynamic programming)
   * is used for storing the interim values.
   */
  std::vector<int> line(k + 1, 0);
  std::vector<std::vector<int>> dp(n + 1, line);
  dp[0][0] = 1;

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= k; j++) {
      for (int q = 0; q < j; q++) {
        dp[i][j] += dp[i - 1][q];
      }
    }
  }

  int sum = 0;
  for (int j = 1; j <= k; j++) {
    sum += dp[n][j];
  }

  return sum;
}


int nearestRoundNumber(int value) {
     while (value % 10 != 0)
            {
                value++;
            }

            return value;
}



int countWaysToChangeDigit(int value) {
int answer = 0;
        while (value > 0) {
            answer += 9 - value % 10;
            value /= 10;
        }
        return answer;
}

bool isSkewSymmetricMatrix(std::vector<std::vector<int>> matrix) {
for (int i = 0; i < matrix.size(); i++) {
        for (int j = 0; j < matrix.size(); j++) {
            if (matrix[i][j] + matrix[j][i] != 0) {
                return false;
            }
        }
    }
    return true;
}

static int commonCharacterCount(string s1, string s2)
        {
            char[] ch_s1 = new char[26];
            char[] ch_s2 = new char[26];

            for (int i = 0; i < s1.Length; i++)
            {
                ch_s1[s1[i] - 'a']++;
            }
            for (int i = 0; i < s2.Length; i++)
            {
                ch_s2[s2[i] - 'a']++;
            }

            int ans = 0;
            for (int i = 0; i < 26; i++)
            {

                ans += Math.Min(ch_s1[i] , ch_s2[i]);
            }
            return ans;

        }


        bool checkSameElementExistence(int[] arr1, int[] arr2)
        {
            HashSet<int> hash = new HashSet<int>(arr2);

            for (int i = 0; i < arr1.Length; i++)
            {
                if (hash.Contains(arr1[i])) return true;
            }

            return false;
        }



function numberOfTriangles2(sticks) {
var ans = 0;
  for (var i = 0; i < sticks.length - 2; i++) {
    for (var j = i + 1; j < sticks.length - 1; j++) {
      var mx = sticks[i] + sticks[j];
      var l = j,
          r = sticks.length ;
      while (r - l > 1) {
        var m = Math.floor((l + r) / 2);
        if (sticks[m] >= mx) {
          r = m;
        } else {
          l = m;
        }
      }
      ans += r - j - 1;
    }
  }

  return ans;
}


static  string insertDashes(string inputString)
        {
            string[] espacios = inputString.Split(' ');

            for (int i = 0; i < espacios.Length; i++)
            {
                string linea = "";
                for (int j = 0; j < espacios[i].Length; j++)
                {
                    linea += espacios[i][j] + "-";
                }
                linea = linea.TrimEnd('-');
                espacios[i] = linea;
            }

            string ans = "";
            for (int i = 0; i < espacios.Length; i++)
            {
                ans += espacios[i] + " ";
            }
            return ans.TrimEnd(' ') ;
        }

        bool isCaseInsensitivePalindrome(string inputString)
        {

            inputString = inputString.ToLower();
            int i = 0, j = inputString.Length - 1;

            while (i < j)
            {
                if (inputString[i] != inputString[j])
                {
                    return false;
                }

                i++;
                j--;
            }
            return true;
        }


bool checkEqualFrequency(std::vector<int> inputArray) {

  int numberOfEqual = 1;

  std::sort(inputArray.begin(), inputArray.end());

  while (numberOfEqual < inputArray.size()
      && inputArray[numberOfEqual - 1] == inputArray[numberOfEqual]) {
    numberOfEqual++;
  }

  if (inputArray.size() % numberOfEqual != 0) {
    return false;
  }

  for (int i = 0; i < inputArray.size(); i += numberOfEqual) {
    if (i && inputArray[i] == inputArray[i - 1]) {
      return false;
    }
    for (int j = i + 1; j < i + numberOfEqual; j++) {
      if (inputArray[j] != inputArray[j - 1]) {
        return false;
      }
    }
  }

  return true;
}




string insertDashes(string inputString) {
string[] espacios = inputString.Split(' ');

            for (int i = 0; i < espacios.Length; i++)
            {
                string linea = "";
                for (int j = 0; j < espacios[i].Length; j++)
                {
                    linea += espacios[i][j] + "-";
                }
                linea = linea.TrimEnd('-');
                espacios[i] = linea;
            }

            string ans = "";
            for (int i = 0; i < espacios.Length; i++)
            {
                ans += espacios[i] + " ";
            }
            return ans.TrimEnd(' ') ;
}



int arithmeticProgression(int element1, int element2, int n) {
     int cont = 1;
            int i = element1;
            int dif = element2 - element1;
            for ( ; cont < n; i += dif)
            {
                //i += element2 - element1;
               // lista.Add(i);
                cont++;
                //Console.WriteLine(i);
            }

            return i;
}



 int gcd(int a, int b)
        {
            if (a == 0)
                return b;
            return gcd(b % a, a);
        } 


        int eulersTotientFunction(int n)
        {
            int result = 1;
            for (int i = 2; i < n; i++)
                if (gcd(i, n) == 1)
                    result++;
            return result;
        }




int sumOfCubes(int n)
        {
            int sum = 0;
            for (int i = 1; i <= n; i++)
            {
                sum += i * i * i;
            }
            return sum;
        }

        char firstDigit(string inputString)
        {
            for (int i = 0; i < inputString.Length; i++)
            {
                if (char.IsDigit(inputString[i]))
                {
                    return inputString[i];
                }

            }
            return '0';
        }


       static  bool isSumOfConsecutive(int n)
        {
            int sum = 0;
            for (int i = 1; i < n; i++)
            {
                sum = 0;
                for (int j = i; ; j++)
                {
                    if (sum > n) break;
                    if (sum == n) return true;
                    sum += j;
                }

            }
            return false;
        }


bool isSumOfConsecutive(int n) {
    int sum = 0;
            for (int i = 1; i < n; i++)
            {
                sum = 0;
                for (int j = i; ; j++)
                {
                    if (sum > n) break;
                    if (sum == n) return true;
                    sum += j;
                }

            }
            return false;
}


 static string integerToStringOfFixedWidth(int number, int width)
        {

            string s = number.ToString();

            if (width < s.Length)
            {
                return s.Substring(s.Length - width);
            }
            else if (width > s.Length)
            {
                return new string('0', width - s.Length) + s;
            }
            return s;

        }

 int sumOfCubes(int n)
        {
            int sum = 0;
            for (int i = 1; i <= n; i++)
            {
                sum += i * i * i;
            }
            return sum;
        }

        char firstDigit(string inputString)
        {
            for (int i = 0; i < inputString.Length; i++)
            {
                if (char.IsDigit(inputString[i]))
                {
                    return inputString[i];
                }

            }
            return '0';
        }

        static string integerToStringOfFixedWidth(int number, int width)
        {

            string s = number.ToString();

            if (width < s.Length)
            {
                return s.Substring(s.Length - width);
            }
            else if (width > s.Length)
            {
                return new string('0', width - s.Length) + s;
            }
            return s;

        }

 
string integerToStringOfFixedWidth(int number, int width) {
    string s = number.ToString();

            if (width < s.Length)
            {
                return s.Substring(s.Length - width);
            }
            else if (width > s.Length)
            {
                return new string('0', width - s.Length) + s;
            }
            return s;
}

private static int knapsackLight(int value1, int weight1,
                                     int value2, int weight2, int maxW) {

        if (weight1 + weight2 <= maxW) {
            return value1 + value2;
        }
        if (Math.min(weight1, weight2) > maxW) {
            return 0;
        }
        if (weight1 <= maxW && (value1 >= value2 || weight2 > maxW)) {
            return value1;
        }
        return value2;
    }


int commonPoints(int l1, int r1, int l2, int r2) {
   int result = Math.min(r1, r2) - Math.max(l1, l2) - 1;
        if (result < 0) {
            result = 0;
        }
        return result;
}



bool isInfiniteProcess(int a, int b) {
      if(b>=a && (b-a)%2==0) {
            return false;
        }
        
        return true;
        
}


bool isInformationConsistent(std::vector<std::vector<int>> evidences) {
    for (int i{}; i < evidences[0].size(); ++i) {
        int neg{},
            pos{};
        for (int j{}; j < evidences.size(); ++j) {
            neg += evidences[j][i] < 0;
            pos += evidences[j][i] > 0;
        }

        if (neg && pos)
            return 0;
    }

    return true;
} 


std::string knapsackLight2(int a, int b, int c) {
    if (a + b <= c)
        return "both";
    if (a <= c && b <= c)
        return "either";
    if (a <= c)
        return "first";
    if (b <= c)
        return "second";
    return "none";
}

def parkingCost(timeIn, timeOut):
    diff = (int(timeOut[:2]) * 60 +
        int(timeOut[3:]) -
        int(timeIn[:2]) * 60 -
        int(timeIn[3:]))
    if diff <= 30:
        return 0
    if diff <= 120:
        return (diff - 21) // 10
    return 9 + ((diff - 111) // 10) * 2

-----------------------
int CargarFilaArriba(int num, int en_fila, int[][] m, int col_izq, int col_der)
    {
        for (int i = col_izq; i <= col_der; i++)
        {
            m[en_fila][i] = num++;
        }
        return num;
    }

     int CargarFilaAbajo(int num, int en_fila, int[][] m, int col_izq, int col_der)
    {
        for(int i = col_der; i>= col_izq; i--)
        {
            m[en_fila][i] = num++;
        }
        return num;
    }

     int CargarColDer(int num, int en_col, int[][] m, int fila_arriba, int fila_abajo)
    {
        for (int i = fila_arriba; i <= fila_abajo; i++)
        {
            m[i][en_col] = num++;
        }

        return num;
    }

     int CargarColIzq(int num, int en_col, int[][] m, int fila_arriba, int fila_abajo)
    {
        for (int i = fila_abajo; i >= fila_arriba; i--)
        {
            m[i][en_col] = num++;
        }
        return num;
    }



     int[][] spiralNumbers(int n)
    {
        int i = 0;
        int j = n;
        int[][] matriz = new int[n][];

        for (i = 0; i < n; i++)
        {
            matriz[i] = new int[n];
        }

        int num = 1;

        int fila_arriba = 0, fila_abajo = n - 1;
        int col_izq = 0, col_der = n - 1;

        while (fila_arriba <= fila_abajo &&
            col_izq <= col_der)
        {
            num = CargarFilaArriba(num, fila_arriba, matriz, col_izq, col_der);
            fila_arriba++;
            num = CargarColDer(num, col_der, matriz, fila_arriba, fila_abajo);
            col_der--;
            num = CargarFilaAbajo(num, fila_abajo, matriz, col_izq, col_der);
            fila_abajo--;
            num = CargarColIzq(num, col_izq, matriz, fila_arriba, fila_abajo);
            col_izq++;
        }

        return matriz;
    }

---------------------------

def cipher26(message):
    def dig(x):
        return ord(x)-97
    def let(x):
        return chr(x+97)
    
    s = 0
    ans = ''
    for x in message:
        ans += let( (dig(x) - s)%26 )
        s = dig(x)
    return ans



int parabole(int a, int b, int c, int x) {
  return   (int) (a * Math.pow(x, 2) + b * x + c);
}



bool arithmeticExpression(int a, int b, int c)
        {
            double x = (double)a;
            double y = (double)b;
            double z = (double)c;
            return x + y == z || x - y == z || x / y == z || x * y == z;
        }

        bool checkFactorial(int n)
        {
            int prod = 1;
            for (int i = 1;prod <=n ; i++)
            {
                prod *= i;
                if (prod == n) return true;

            }
            return false;
        }


      function centuryFromYear(year) {
    var newYear = year.toString().length;
    var stYear
    if (newYear >= 4){
        stYear = year.toString().substring(0, 2);
        if (year % 100 !== 0){ 
        return (parseInt(stYear)+1);
        } else {
        return parseInt(stYear);  
        };
    } else if (newYear >= 3){
        stYear = year.toString().substring(0,1);
        if (year % 100 !== 0){ 
        return (parseInt(stYear)+1);
        } else {
        return parseInt(stYear);  
        };
    } else if (newYear < 3){
        return 1;
    };
};



int centuryFromYear(int year) {
    for (int i = 1; ; i++)
            {
                if (year >= i && year <= i * 100)
                {
                    return i;
                }

            }
}
   

int digitDistanceNumber(int n)
        {
            string s = n.ToString();

            string concat = "";
            for (int i = 0; i + 1 < s.Length; i++)
            {
                concat +=  Math.Abs( (s[i] - '0') - (s[i + 1] - '0'));
            }
            return int.Parse(concat);
        }

  string reflectString(string inputString)
        {
            string ans = "";
            for (int i = 0; i < inputString.Length; i++)
            {
                ans +=  (char)( 'a' - inputString[i] + 'z');
            }
            return ans;
        }



string reflectString(string inputString) {
     string ans = "";
            for (int i = 0; i < inputString.Length; i++)
            {
                ans +=  (char)( 'a' - inputString[i] + 'z');
            }
            return ans;
}

bool robotWalk(std::vector<int> a) {
    int minX = 0;
    int minY = -1;
    int maxX = INT_MAX;
    int maxY = INT_MAX;

    int x = 0;
    int y = 0;

    for (int i = 0; i < a.size(); i++) {
        switch (i % 4) {

        case 0:
            y += a[i];
            if (y >= maxY) {
                return true;
            }
            maxY = y;
            break;

        case 1:
            x += a[i];
            if (x >= maxX) {
                return true;
            }
            maxX = x;
            break;

        case 2:
            y -= a[i];
            if (y <= minY) {
                return true;
            }
            minY = y;
            break;

        case 3:
            x -= a[i];
            if (x <= minX) {
                return true;
            }
            minX = x;
            break;
        }
    }

    return false;
} 


static int fibonacciNumber(int n)
        {

            List<int> fibs = new List<int>();
            fibs.Add(0);
            fibs.Add(1);
            for (int i = 2; i <= n; i++)
            {
                fibs.Add(fibs[i - 1] + fibs[i - 2]);
            }

            return fibs[n];
        }



   string replaceAllDigitsRegExp(string input)
        {
            for (char i = '0'; i <= '9'; i++)
            {
                input = input.Replace(i, '#');
            }
            return input;
        }

        static int calculationsWithCoins(int a, int b, int c)
        {
            HashSet<int> hash = new HashSet<int>();
            hash.Add(a);
            hash.Add(b);
            hash.Add(c);

            hash.Add(a +b );
            hash.Add(a +c);
            hash.Add(b+c);

            hash.Add(a+b+c);

            return hash.Count;

        }


        bool arithmeticExpression(int a, int b, int c)
        {
            if ((double)a + (double)b == (double)c) return true;
            if ((double)a - (double)b == (double)c) return true;
            if ((double)a / (double)b == (double)c) return true;
            if ((double)a * (double)b == (double)c) return true;
            return false;

        }



 string[] splitAddress(string address)
        {
            string[] s = address.Split(new string[] {"://",".", "/"}, StringSplitOptions.RemoveEmptyEntries);

            List<string> ans = new List<string>();
            for (int i = 0; i < s.Length; i++)
            {
                if (s[i] != "com") ans.Add(s[i]);
            }
            return ans.ToArray();

        }

        int sumOfDivisors(int n)
        {
            int sum = 0;
            for (int i = 1; i <= n; i++)
            {
                sum += n % i == 0 ? i : 0;
            }
            return sum;
        }

        int telephoneGame(string[] messages)
        {
            string actual = messages[0];
            for (int i = 1; i < messages.Length; i++)
            {
                if (messages[i] != actual) return i;
            }
            return -1;
        }



   bool areIsomorphic(int[][] array1, int[][] array2)
        {

            if (array1.Length == array2.Length)
            {

                for (int i = 0; i < array1.Length; i++)
                {
                    if (array1[i].Length != array2[i].Length)
                    {
                        return false;
                    }
                     
                }
                return true;
            }
            return false;

        }

        int divisorsSubset(int[] subset, int n)
        {
            int cont = 0;
            for (int i = 1; i <= n; i++)
            {
                int j = 0;
                for (; j < subset.Length; j++)
                {
                    if (i % subset[j] != 0) break;
                }
                if (j >= subset.Length)
                {
                    cont++;
                }
            }
            return cont;
        }



        string myConcat(string[] strings, string separator)
        {
            string s = "";

            for (int i = 0; i < strings.Length; i++)
            {
                s += strings[i] + separator;

            }
            return s;
        }



int[][] spiralNumbers(int n) {
  int[][] m = new int[n][n];
  int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
  int currentDirectionIndex = 0;
  int currentRow = 0;
  int currentColumn = 0;
  int currentNum = 1;
  int tmpRow;
  int tmpColumn;
  for (int i = n*n; i > 0; i--) {
    m[currentRow][currentColumn] = currentNum;
    currentNum++;
    if (i > 1) {
      // Determine the next cell
      while (true) {
        tmpRow = currentRow + directions[currentDirectionIndex][0];
        tmpColumn = currentColumn + directions[currentDirectionIndex][1];
        if (tmpRow < 0 || tmpRow >= n ||
            tmpColumn < 0 || tmpColumn >= n ||
            m[tmpRow][tmpColumn] != 0) {
          currentDirectionIndex = (currentDirectionIndex + 1) % 4;
        } else {
          currentRow = tmpRow;
          currentColumn = tmpColumn;
          break;
        }
      }
    }
  }
  return m;
}




bool isMAC48Address(std::string inputString) {

  for (int i = 0; i < inputString.size(); i++) {
    if ( (i+1) %3 ==0) {
      if (inputString[i] != '-') {
        return false;
      }
    }
    else {
      char sym = inputString[i];
      if (!('0' <= sym && sym <= '9' || 'A' <= sym && sym <= 'F')) {
        return false;
      }
    }
  }

  return inputString.size() == 17;
}



double computeDefiniteIntegral(int l, int r, int[] p) {
 double result = 0;
        int lExp = l,
                rExp = r;

        for (int i = 0; i < p.length; i++) {
            result += p[i] * (double) (rExp - lExp) / (i + 1);
            lExp *= l;
            rExp *= r;
        }

        return result;
}

bool isLucky(int n) {
      int len = 0;
            int totalsum = 0;
            int copia = n;
            while (copia > 0)
            {
                len++;
                totalsum += copia % 10;
                copia /= 10;
            }

            int copia2 = n;
            int mitad = 0;
            int cont =0;
            while (cont < len/2)
            {
                int dig = copia2 % 10;
                mitad += dig;
                cont++;
                copia2 /=10;
            }

            return totalsum - mitad == mitad;
}


int appleBoxes(int k) {
	int sum =  (1 + k) * k / 2;
   	 return (k % 2 == 1) ? -sum : sum;
}


   static int[][] swapDiagonals(int[][] matrix)
        {

            for (int i = 0; i < matrix.Length; i++)
            {
                int temp = matrix[i][i];
                matrix[i][i] = matrix[i][matrix.Length - i - 1];
                matrix[i][matrix.Length - i - 1] = temp;
            }

            return matrix;
        }


   int gcm(int a, int b) {
        return b == 0 ? a : gcm(b, a % b);
    }

        int[] fractionSum(int[] A, int[] B) {
        int[] sum = new int[]{(A[0] * B[1]) + (B[0] * A[1]), (A[1] * B[1])};
        int gcm = gcm(sum[0], sum[1]);
        return new int[]{sum[0] / gcm, sum[1] / gcm};
    }




bool alphabetSubsequence(string s) {
for (int i = 0; i +1 < s.Length; i++)
            {
                if (s[i] >= s[i + 1]) return false;

            }
            return true;
}



boolean pointInLine(int[] point, int[] line) {
return line[0] * point[0] + line[1] * point[1] + line[2] == 0;
}


static int comfortableNumbers(int L, int R)
        {

            int total_pairs = 0;

            for (int i = L; i <= R; i++)
            {
                for (int j = i + 1; j <= R; j++)
                {
                    int s_a = 0; // digitSum(i);
                    int s_b = 0; // digitSum(j);

                    //int _sum = 0;
                    int c_i = i;
                    while (c_i > 0)
                    {
                        s_a += (c_i % 10);
                        c_i = c_i / 10;
                    }

                    int c_j = j;
                    while (c_j > 0)
                    {
                        s_b += (c_j % 10);
                        c_j = c_j / 10;
                    }

                    if (j >= (i - s_a) && j <= (i + s_a) &&
                          i >= (j - s_b) && i <= (j + s_b)
                       )
                    {
                        total_pairs++;
                    }
                }
            }
            return total_pairs;
        }


int[] primeFactors2(int n) {

            HashSet<int> hash = new HashSet<int>();
            while (n % 2 == 0)
            {
                //Console.Write(2 + " ");
                hash.Add(2);
                n /= 2;
            }

          
            for (int i = 3; i *i <= n; i += 2)
            {
                
                while (n % i == 0)
                {
                   
                    hash.Add(i);
                    n /= i;
                }
            }

           
            if (n > 2)
            {
        
                hash.Add(n);
            }
            return hash.ToArray();
}


string decipher(string cipher) {
	string result="";
    while(cipher.Length>0) {
        string s = cipher.Substring(0,2);
        int n = int.Parse(s);
        if(n>=97) {
            result+=(char)n;
            cipher = cipher.Substring(2);
        }else {
            s = cipher.Substring(0,3);
            n = int.Parse(s);
            result+=(char)n;
            cipher = cipher.Substring(3);
        }
    }
    return result;
}


int[] nextSecond(int[] currentTime)
        {
            currentTime[2]++;

            if (currentTime[2] > 59)
            {
                currentTime[2] = 0;
                currentTime[1]++;
                if (currentTime[1] > 59)
                {
                    currentTime[1] = 0;
                    currentTime[0]++;
                    if (currentTime[0] > 23)
                    {
                        currentTime[0] = 0;
                    }
                }
            }

            return currentTime;
        }



private static int combs(String comb1, String comb2) {

        class Helper {
            int getMask(String comb) {
                int mask = 0;
                for (int i = 0; i < comb.length(); i++) {
                    char c = comb.charAt(i);
                    mask = (mask << 1) + (c == '*' ? 1 : 0);
                }
                return mask;
            }
        }
        Helper h = new Helper();

        int m1 = h.getMask(comb1);
        int m2 = h.getMask(comb2);
        int len1 = comb1.length();
        int len2 = comb2.length();
        int answer = len1 + len2;
        for (int i = -len1; i <= len2; i++) {
            int tmp, length;
            if (i < 0) {
                tmp = m2 << (-i) & m1;
                length = Math.max(-i + len2, len1);
            } else {
                tmp = m1 << i & m2;
                length = Math.max(i + len1, len2);
            }
            if (tmp == 0 && answer > length) {
                answer = length;
            }
        }

        return answer;
    }


int crossingSum(int[][] matrix, int a, int b) {
    int sum = 0;
            for (int i = 0; i < matrix[0].Length; i++)
            {
                sum += matrix[a][i];
            }
            for (int i = 0; i < matrix.Length; i++)
            {
                sum += matrix[i][b];
            }
            sum -= matrix[a ][b ];
            return sum;
}


std::vector<int> prefixFunctionNaive(std::string s) {
std::vector<int> result;

    for (int i = 0; i < s.size(); i++) {
        result.push_back(0);
        //cout << "i=" << i << endl;
        for (result[i] = i; result[i] >= 0; result[i]--) {
            //cout << "result=" << result << endl;
            bool matches = true;
            for (int j = i - result[i] + 1; j <= i; j++) {
                //cout << "s[" << j << "]=" << s[j] << ", ";
                //cout << "s[" << j - i + result[i] - 1 << "]=" << s[j - i + result[i] - 1] << endl;
                if (s[j] != s[j - i + result[i] - 1]) {
                    matches = false;
                    break;
                }
            }
            if (matches) {
                break; // continue; -> break;
            }
        }
    }

    return result;
}


bool isLucky(int n) {

  std::vector<int> digits;
  int sum = 0;

  while (n > 0) {
    digits.push_back(n % 10);
    n /= 10;
  }

  for (int i = 0; i < digits.size(); i++) {
    if (i < digits.size() / 2) {
      sum += digits[i];
    }
    else {
      sum -= digits[i];
    }
  }

  if (sum) {
    return false;
  }
  return true;
}



def countWays(n, k):
    res=1
    for i in range (k):
        res = ((res*(n-i))//(i+1))
    return res%1000000007

int maximumSubsetProduct(std::vector<int> a) {
int mnn = -1111111111;
    int cnt = 0;
    for(int i=0;i<a.size();++i)
    {
        if(a[i] > 0)
            continue;
        mnn = max(mnn , a[i]);
        cnt++;
    }
    if(cnt % 2 == 0 || a.size() == 1)
        return 1;
    return mnn;
}

std::vector<int> powersOfTwo(int n) {

  std::vector<int> ans;
  int cur = 1;
  while (n > 0) {
    if (n % 2 == 0) {
      ans.push_back(cur);
    }
    n <<= 1;
    cur <<= 1;
  }

  return ans;
}

def binaryGenerator(s):
    a = set()
    a.add('')
    for i in range (len(s)):
        b = set()
        for c in a:
            b.add(c+"1")
            if s[i]=='0':
                b.add(c+"0")
        a=b
    r=list(a)
    r.sort()
    return r


static  bool isGeometricProgression(int[] sequence)
{
            bool flag1 = true ;
            bool flag2 = true ;
            double dif = (double)sequence[0] / (double)sequence[1];

            for (int i = 1; i  + 1< sequence.Length; i++)
            {
                if ((double)sequence[i] / (double)sequence[i + 1] != dif)
                   
                {
                      flag1 = false;
                      break;
                }

            }
            dif = (double)sequence[1] / (double)sequence[0];
            for (int i = 1; i + 1 < sequence.Length; i++)
            {
                if ((double)sequence[i + 1] / (double)sequence[i] != dif)
                    
                {
                    flag2 = false;
                    break;
                }

            }

            return flag1 || flag2;

}

static int growingPlant(int upSpeed, int downSpeed, int desiredHeight)
        {
            int sum = 0;
            int cont = 0;
            while (true)
            {
                sum += upSpeed;
                cont++;
                if (sum >= desiredHeight)
                {
                    break;
                }
                sum -= downSpeed;
            }
            return cont;
        }

